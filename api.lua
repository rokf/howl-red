return { 
  ['%'] = { description = "\nUSAGE:\n      value1 %  value2\n\nDESCRIPTION:\n      Returns what is left over when one value is divided by another. \n      % is of type: op! \n\nARGUMENTS:\n     value1   [number! char! pair! tuple! vector! time!] \n     value2   [number! char! pair! tuple! vector! time!] \n\nREFINEMENTS:\n" },
  ['*'] = { description = "\nUSAGE:\n      value1 *  value2\n\nDESCRIPTION:\n      Returns the product of two values. \n      * is of type: op! \n\nARGUMENTS:\n     value1   [number! char! pair! tuple! vector! time!] \n     value2   [number! char! pair! tuple! vector! time!] \n\nREFINEMENTS:\n" },
  ['**'] = { description = "\nUSAGE:\n      number **  exponent\n\nDESCRIPTION:\n      Returns a number raised to a given power (exponent). \n      ** is of type: op! \n\nARGUMENTS:\n     number   [number!]  => Base value. \n     exponent   [number!]  => The power (index) to raise the base value by. \n\nREFINEMENTS:\n" },
  ['+'] = { description = "\nUSAGE:\n      value1 +  value2\n\nDESCRIPTION:\n      Returns the sum of the two values. \n      + is of type: op! \n\nARGUMENTS:\n     value1   [number! char! pair! tuple! vector! time!] \n     value2   [number! char! pair! tuple! vector! time!] \n\nREFINEMENTS:\n" },
  ['-'] = { description = "\nUSAGE:\n      value1 -  value2\n\nDESCRIPTION:\n      Returns the difference between two values. \n      - is of type: op! \n\nARGUMENTS:\n     value1   [number! char! pair! tuple! vector! time!] \n     value2   [number! char! pair! tuple! vector! time!] \n\nREFINEMENTS:\n" },
  ['/'] = { description = "\nUSAGE:\n      value1 /  value2\n\nDESCRIPTION:\n      Returns the quotient of two values. \n      / is of type: op! \n\nARGUMENTS:\n     value1   [number! char! pair! tuple! vector! time!]  => The dividend (numerator). \n     value2   [number! char! pair! tuple! vector! time!]  => The divisor (denominator). \n\nREFINEMENTS:\n" },
  ['//'] = { description = "\nUSAGE:\n      a //  b\n\nDESCRIPTION:\n      Wrapper for MOD that handles errors like REMAINDER. Negligible values (compared to A and B) are rounded to zero. \n      // is of type: op! \n\nARGUMENTS:\n     a   [number! char! pair! tuple! vector! time!] \n     b   [number! char! pair! tuple! vector! time!] \n\nREFINEMENTS:\n" },
  ['<'] = { description = "\nUSAGE:\n      value1 <  value2\n\nDESCRIPTION:\n      Returns TRUE if the first value is less than the second. \n      < is of type: op! \n\nARGUMENTS:\n     value1   [any-type!] \n     value2   [any-type!] \n\nREFINEMENTS:\n" },
  ['<<'] = { description = "\nUSAGE:\n      data <<  bits\nARGUMENTS:\n     data   [integer!] \n     bits   [integer!] \n\nREFINEMENTS:\n" },
  ['<='] = { description = "\nUSAGE:\n      value1 <=  value2\n\nDESCRIPTION:\n      Returns TRUE if the first value is less than or equal to the second. \n      <= is of type: op! \n\nARGUMENTS:\n     value1   [any-type!] \n     value2   [any-type!] \n\nREFINEMENTS:\n" },
  ['<>'] = { description = "\nUSAGE:\n      value1 <>  value2\n\nDESCRIPTION:\n      Returns TRUE if two values are not equal. \n      <> is of type: op! \n\nARGUMENTS:\n     value1   [any-type!] \n     value2   [any-type!] \n\nREFINEMENTS:\n" },
  ['='] = { description = "\nUSAGE:\n      value1 =  value2\n\nDESCRIPTION:\n      Returns TRUE if two values are equal. \n      = is of type: op! \n\nARGUMENTS:\n     value1   [any-type!] \n     value2   [any-type!] \n\nREFINEMENTS:\n" },
  ['=='] = { description = "\nUSAGE:\n      value1 ==  value2\n\nDESCRIPTION:\n      Returns TRUE if two values are equal, and also the same datatype. \n      == is of type: op! \n\nARGUMENTS:\n     value1   [any-type!] \n     value2   [any-type!] \n\nREFINEMENTS:\n" },
  ['=?'] = { description = "\nUSAGE:\n      value1 =?  value2\n\nDESCRIPTION:\n      Returns TRUE if two values have the same identity. \n      =? is of type: op! \n\nARGUMENTS:\n     value1   [any-type!] \n     value2   [any-type!] \n\nREFINEMENTS:\n" },
  ['>'] = { description = "\nUSAGE:\n      value1 >  value2\n\nDESCRIPTION:\n      Returns TRUE if the first value is greater than the second. \n      > is of type: op! \n\nARGUMENTS:\n     value1   [any-type!] \n     value2   [any-type!] \n\nREFINEMENTS:\n" },
  ['>='] = { description = "\nUSAGE:\n      value1 >=  value2\n\nDESCRIPTION:\n      Returns TRUE if the first value is greater than or equal to the second. \n      >= is of type: op! \n\nARGUMENTS:\n     value1   [any-type!] \n     value2   [any-type!] \n\nREFINEMENTS:\n" },
  ['>>'] = { description = "\nUSAGE:\n      data >>  bits\nARGUMENTS:\n     data   [integer!] \n     bits   [integer!] \n\nREFINEMENTS:\n" },
  ['>>>'] = { description = "\nUSAGE:\n      data >>>  bits\nARGUMENTS:\n     data   [integer!] \n     bits   [integer!] \n\nREFINEMENTS:\n" },
  ['?'] = { description = "\nUSAGE:\n      ? 'word\n\nDESCRIPTION:\n      Display helping information about words and other values. \n      ? is of type: function! \n\nARGUMENTS:\n     'word   [any-type!]  => Word you are looking for. \n\nREFINEMENTS:\n" },
  ['??'] = { description = "\nUSAGE:\n      ?? 'value\n\nDESCRIPTION:\n      Prints a word and the value it refers to (molded). \n      ?? is of type: function! \n\nARGUMENTS:\n     'value   [word!] \n\nREFINEMENTS:\n" },
  ['a-an'] = { description = "\nUSAGE:\n      a-an s\nARGUMENTS:\n     s   [string!] \n\nREFINEMENTS:\n" },
  ['about'] = { description = "\nUSAGE:\n      about \n\nDESCRIPTION:\n      Print Red version information. \n      about is of type: function! \n\nARGUMENTS:\n\nREFINEMENTS:\n" },
  ['absolute'] = { description = "\nUSAGE:\n      absolute value\n\nDESCRIPTION:\n      Returns the non-negative value. \n      absolute is of type: action! \n\nARGUMENTS:\n     value   [number! pair! time!] \n\nREFINEMENTS:\n" },
  ['acos'] = { description = "\nUSAGE:\n      acos angle\n\nDESCRIPTION:\n      Returns the trigonometric arccosine. \n      acos is of type: function! \n\nARGUMENTS:\n     angle   [float!]  => Angle in radians. \n\nREFINEMENTS:\n" },
  ['action?'] = { description = "\nUSAGE:\n      action? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      action? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['add'] = { description = "\nUSAGE:\n      add value1 value2\n\nDESCRIPTION:\n      Returns the sum of the two values. \n      add is of type: action! \n\nARGUMENTS:\n     value1   [number! char! pair! tuple! vector! time!] \n     value2   [number! char! pair! tuple! vector! time!] \n\nREFINEMENTS:\n" },
  ['all'] = { description = "\nUSAGE:\n      all conds\n\nDESCRIPTION:\n      Evaluates, returning at the first that is not true. \n      all is of type: native! \n\nARGUMENTS:\n     conds   [block!] \n\nREFINEMENTS:\n" },
  ['also'] = { description = "\nUSAGE:\n      also value1 value2\n\nDESCRIPTION:\n      Returns the first value, but also evaluates the second.. \n      also is of type: function! \n\nARGUMENTS:\n     value1   [any-type!] \n     value2   [any-type!] \n\nREFINEMENTS:\n" },
  ['alter'] = { description = "\nUSAGE:\n      alter series value\n\nDESCRIPTION:\n      If a value is not found in a series, append it; otherwise, remove it. Returns true if added. \n      alter is of type: function! \n\nARGUMENTS:\n     series   [series!] \n     value \n\nREFINEMENTS:\n" },
  ['and'] = { description = "\nUSAGE:\n      value1 and  value2\n\nDESCRIPTION:\n      Returns the first value ANDed with the second. \n      and is of type: op! \n\nARGUMENTS:\n     value1   [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n     value2   [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n\nREFINEMENTS:\n" },
  ['and~'] = { description = "\nUSAGE:\n      and~ value1 value2\n\nDESCRIPTION:\n      Returns the first value ANDed with the second. \n      and~ is of type: action! \n\nARGUMENTS:\n     value1   [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n     value2   [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n\nREFINEMENTS:\n" },
  ['any'] = { description = "\nUSAGE:\n      any conds\n\nDESCRIPTION:\n      Evaluates, returning at the first that is true. \n      any is of type: native! \n\nARGUMENTS:\n     conds   [block!] \n\nREFINEMENTS:\n" },
  ['any-block?'] = { description = "\nUSAGE:\n      any-block? value\n\nDESCRIPTION:\n      Returns true if the value is any type of any-block. \n      any-block? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['any-function?'] = { description = "\nUSAGE:\n      any-function? value\n\nDESCRIPTION:\n      Returns true if the value is any type of any-function. \n      any-function? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['any-list?'] = { description = "\nUSAGE:\n      any-list? value\n\nDESCRIPTION:\n      Returns true if the value is any type of any-list. \n      any-list? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['any-object?'] = { description = "\nUSAGE:\n      any-object? value\n\nDESCRIPTION:\n      Returns true if the value is any type of any-object. \n      any-object? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['any-path?'] = { description = "\nUSAGE:\n      any-path? value\n\nDESCRIPTION:\n      Returns true if the value is any type of any-path. \n      any-path? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['any-string?'] = { description = "\nUSAGE:\n      any-string? value\n\nDESCRIPTION:\n      Returns true if the value is any type of any-string. \n      any-string? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['any-word?'] = { description = "\nUSAGE:\n      any-word? value\n\nDESCRIPTION:\n      Returns true if the value is any type of any-word. \n      any-word? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['append'] = { description = "\nUSAGE:\n      append series value /part length /only /dup count\n\nDESCRIPTION:\n      Inserts value(s) at series tail; returns series head. \n      append is of type: action! \n\nARGUMENTS:\n     series   [series! bitset! map!] \n     value   [any-type!] \n\nREFINEMENTS:\n     /part  => Limit the number of values inserted. \n         length   [number! series!] \n     /only  => Insert block types as single values (overrides /part). \n     /dup  => Duplicate the inserted values. \n         count   [number!] \n" },
  ['arccosine'] = { description = "\nUSAGE:\n      arccosine angle /radians\n\nDESCRIPTION:\n      Returns the trigonometric arccosine (in degrees by default). \n      arccosine is of type: native! \n\nARGUMENTS:\n     angle   [number!] \n\nREFINEMENTS:\n     /radians  => Angle is specified in radians. \n" },
  ['arcsine'] = { description = "\nUSAGE:\n      arcsine angle /radians\n\nDESCRIPTION:\n      Returns the trigonometric arcsine (in degrees by default). \n      arcsine is of type: native! \n\nARGUMENTS:\n     angle   [number!] \n\nREFINEMENTS:\n     /radians  => Angle is specified in radians. \n" },
  ['arctangent'] = { description = "\nUSAGE:\n      arctangent angle /radians\n\nDESCRIPTION:\n      Returns the trigonometric arctangent (in degrees by default). \n      arctangent is of type: native! \n\nARGUMENTS:\n     angle   [number!] \n\nREFINEMENTS:\n     /radians  => Angle is specified in radians. \n" },
  ['arctangent2'] = { description = "\nUSAGE:\n      arctangent2 y x\n\nDESCRIPTION:\n      Returns the angle of the point y/x in radians, when measured counterclockwise from a circle's x axis (where 0x0 represents the center of the circle). The return value is between -pi and +pi.. \n      arctangent2 is of type: native! \n\nARGUMENTS:\n     y   [number!] \n     x   [number!] \n\nREFINEMENTS:\n" },
  ['as'] = { description = "\nUSAGE:\n      as type spec\n\nDESCRIPTION:\n      Coerce a series into a compatible datatype without copying it. \n      as is of type: native! \n\nARGUMENTS:\n     type   [datatype! block! paren! any-path! any-string!]  => The datatype or example value. \n     spec   [block! paren! any-path! any-string!]  => The series to coerce. \n\nREFINEMENTS:\n" },
  ['as-color'] = { description = "\nUSAGE:\n      as-color r g b\nARGUMENTS:\n     r   [integer!] \n     g   [integer!] \n     b   [integer!] \n\nREFINEMENTS:\n" },
  ['as-ipv4'] = { description = "\nUSAGE:\n      as-ipv4 a b c d\nARGUMENTS:\n     a   [integer!] \n     b   [integer!] \n     c   [integer!] \n     d   [integer!] \n\nREFINEMENTS:\n" },
  ['as-pair'] = { description = "\nUSAGE:\n      as-pair x y\n\nDESCRIPTION:\n      Combine X and Y values into a pair. \n      as-pair is of type: native! \n\nARGUMENTS:\n     x   [integer! float!] \n     y   [integer! float!] \n\nREFINEMENTS:\n" },
  ['as-rgba'] = { description = "\nUSAGE:\n      as-rgba a b c d\nARGUMENTS:\n     a   [integer!] \n     b   [integer!] \n     c   [integer!] \n     d   [integer!] \n\nREFINEMENTS:\n" },
  ['asin'] = { description = "\nUSAGE:\n      asin angle\n\nDESCRIPTION:\n      Returns the trigonometric arcsine. \n      asin is of type: function! \n\nARGUMENTS:\n     angle   [float!]  => Angle in radians. \n\nREFINEMENTS:\n" },
  ['ask'] = { description = "\nUSAGE:\n      ask question\nARGUMENTS:\n     question   [string!] \n\nREFINEMENTS:\n" },
  ['at'] = { description = "\nUSAGE:\n      at series index\n\nDESCRIPTION:\n      Returns a series at a given index. \n      at is of type: action! \n\nARGUMENTS:\n     series   [series!] \n     index   [integer! pair!] \n\nREFINEMENTS:\n" },
  ['atan'] = { description = "\nUSAGE:\n      atan angle\n\nDESCRIPTION:\n      Returns the trigonometric arctangent. \n      atan is of type: function! \n\nARGUMENTS:\n     angle   [float!]  => Angle in radians. \n\nREFINEMENTS:\n" },
  ['atan2'] = { description = "\nUSAGE:\n      atan2 y x\n\nDESCRIPTION:\n      Returns the angle of the point y/x in radians. \n      atan2 is of type: function! \n\nARGUMENTS:\n     y   [number!] \n     x   [number!] \n\nREFINEMENTS:\n" },
  ['attempt'] = { description = "\nUSAGE:\n      attempt value /safer\n\nDESCRIPTION:\n      Tries to evaluate a block and returns result or NONE on error. \n      attempt is of type: function! \n\nARGUMENTS:\n     value   [block!] \n\nREFINEMENTS:\n     /safer  => Capture all possible errors and exceptions. \n" },
  ['back'] = { description = "\nUSAGE:\n      back series\n\nDESCRIPTION:\n      Returns a series at the previous index. \n      back is of type: action! \n\nARGUMENTS:\n     series   [series!] \n\nREFINEMENTS:\n" },
  ['binary?'] = { description = "\nUSAGE:\n      binary? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      binary? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['bind'] = { description = "\nUSAGE:\n      bind word context /copy\nARGUMENTS:\n     word   [block! any-word!] \n     context   [any-word! any-object! function!] \n\nREFINEMENTS:\n     /copy \n" },
  ['bitset?'] = { description = "\nUSAGE:\n      bitset? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      bitset? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['block?'] = { description = "\nUSAGE:\n      block? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      block? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['body-of'] = { description = "\nUSAGE:\n      body-of value\n\nDESCRIPTION:\n      Returns the body of a value that supports reflection. \n      body-of is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['break'] = { description = "\nUSAGE:\n      break  /return value\n\nDESCRIPTION:\n      Breaks out of a loop, while, until, repeat, foreach, etc. \n      break is of type: native! \n\nARGUMENTS:\n\nREFINEMENTS:\n     /return  => Forces the loop function to return a value. \n         value   [any-type!] \n" },
  ['browse'] = { description = "\nUSAGE:\n      browse url\n\nDESCRIPTION:\n      Open web browser to a URL. \n      browse is of type: routine! \n\nARGUMENTS:\n     url   [url!] \n\nREFINEMENTS:\n" },
  ['call'] = { description = "\nUSAGE:\n      call cmd /wait /show /console /shell /input in /output out /error err\n\nDESCRIPTION:\n      Executes a shell command to run another process. \n      call is of type: native! \n\nARGUMENTS:\n     cmd   [string! file!]  => A shell command or an executable file. \n\nREFINEMENTS:\n     /wait  => Runs command and waits for exit. \n     /show  => Force the display of system's shell window (Windows only). \n     /console  => Runs command with I/O redirected to console (CLI console only at present). \n     /shell  => Forces command to be run from shell. \n     /input \n         in   [string! file! binary!]  => Redirects in to stdin. \n     /output \n         out   [string! file! binary!]  => Redirects stdout to out. \n     /error \n         err   [string! file! binary!]  => Redirects stderr to err. \n" },
  ['case'] = { description = "\nUSAGE:\n      case cases /all\n\nDESCRIPTION:\n      Evaluates the block following the first true condition. \n      case is of type: native! \n\nARGUMENTS:\n     cases   [block!]  => Block of condition-block pairs. \n\nREFINEMENTS:\n     /all  => Test all conditions, evaluating the block following each true condition. \n" },
  ['catch'] = { description = "\nUSAGE:\n      catch block /name word\n\nDESCRIPTION:\n      Catches a throw from a block and returns its value. \n      catch is of type: native! \n\nARGUMENTS:\n     block   [block!]  => Block to evaluate. \n\nREFINEMENTS:\n     /name  => Catches a named throw. \n         word   [word! block!]  => One or more names. \n" },
  ['cause-error'] = { description = "\nUSAGE:\n      cause-error err-type err-id args\n\nDESCRIPTION:\n      Causes an immediate error throw, with the provided information. \n      cause-error is of type: function! \n\nARGUMENTS:\n     err-type   [word!] \n     err-id   [word!] \n     args   [block!] \n\nREFINEMENTS:\n" },
  ['cd'] = { description = "\nUSAGE:\n      cd :dir\n\nDESCRIPTION:\n      Changes the active directory path. \n      cd is of type: function! \n\nARGUMENTS:\n     :dir   [file! word! path!]  => New active directory of relative path to the new one. \n\nREFINEMENTS:\n" },
  ['change'] = { description = "\nUSAGE:\n      change series value /part range /only /dup count\n\nDESCRIPTION:\n      Changes a value in a series and returns the series after the change. \n      change is of type: action! \n\nARGUMENTS:\n     series   [series!]  => Series at point to change. \n     value   [any-type!]  => The new value. \n\nREFINEMENTS:\n     /part  => Limits the amount to change to a given length or position. \n         range   [number! series!] \n     /only  => Changes a series as a series.. \n     /dup  => Duplicates the change a specified number of times. \n         count   [number!] \n" },
  ['change-dir'] = { description = "\nUSAGE:\n      change-dir dir\n\nDESCRIPTION:\n      Changes the active directory path. \n      change-dir is of type: function! \n\nARGUMENTS:\n     dir   [file! word! path!]  => New active directory of relative path to the new one. \n\nREFINEMENTS:\n" },
  ['char?'] = { description = "\nUSAGE:\n      char? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      char? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['charset'] = { description = "\nUSAGE:\n      charset spec\nARGUMENTS:\n     spec   [block! integer! char! string!] \n\nREFINEMENTS:\n" },
  ['checksum'] = { description = "\nUSAGE:\n      checksum data method /with spec\n\nDESCRIPTION:\n      Computes a checksum, CRC, hash, or HMAC. \n      checksum is of type: native! \n\nARGUMENTS:\n     data   [binary! string! file!] \n     method   [word!]  => MD5 SHA1 SHA256 SHA384 SHA512 CRC32 TCP hash. \n\nREFINEMENTS:\n     /with  => Extra value for HMAC key or hash table size; not compatible with TCP/CRC32 methods. \n         spec   [any-string! binary! integer!]  => String or binary for MD5/SHA* HMAC key, integer for hash table size. \n" },
  ['class-of'] = { description = "\nUSAGE:\n      class-of value\n\nDESCRIPTION:\n      Returns the class ID of an object. \n      class-of is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['clean-path'] = { description = "\nUSAGE:\n      clean-path file /only /dir\n\nDESCRIPTION:\n      Cleans-up '.' and '..' in path; returns the cleaned path. \n      clean-path is of type: function! \n\nARGUMENTS:\n     file   [file! url! string!] \n\nREFINEMENTS:\n     /only  => Do not prepend current directory. \n     /dir  => Add a trailing / if missing. \n" },
  ['clear'] = { description = "\nUSAGE:\n      clear series\n\nDESCRIPTION:\n      Removes series values from current index to tail; returns new tail. \n      clear is of type: action! \n\nARGUMENTS:\n     series   [series! bitset! map! none!] \n\nREFINEMENTS:\n" },
  ['clear-reactions'] = { description = "\nUSAGE:\n      clear-reactions \n\nDESCRIPTION:\n      Removes all reactive relations. \n      clear-reactions is of type: function! \n\nARGUMENTS:\n\nREFINEMENTS:\n" },
  ['collect'] = { description = "\nUSAGE:\n      collect body /into collected\n\nDESCRIPTION:\n      Collect in a new block all the values passed to KEEP function from the body block. \n      collect is of type: function! \n\nARGUMENTS:\n     body   [block!]  => Block to evaluate. \n\nREFINEMENTS:\n     /into  => Insert into a buffer instead (returns position after insert). \n         collected   [series!]  => The buffer series (modified). \n" },
  ['comment'] = { description = "\nUSAGE:\n      comment value\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['complement'] = { description = "\nUSAGE:\n      complement value\n\nDESCRIPTION:\n      Returns the opposite (complementing) value of the input value. \n      complement is of type: action! \n\nARGUMENTS:\n     value   [logic! integer! bitset! typeset! binary!] \n\nREFINEMENTS:\n" },
  ['complement?'] = { description = "\nUSAGE:\n      complement? bits\n\nDESCRIPTION:\n      Returns TRUE if the bitset is complemented. \n      complement? is of type: native! \n\nARGUMENTS:\n     bits   [bitset!] \n\nREFINEMENTS:\n" },
  ['compose'] = { description = "\nUSAGE:\n      compose value /deep /only /into out\n\nDESCRIPTION:\n      Returns a copy of a block, evaluating only parens. \n      compose is of type: native! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n     /deep  => Compose nested blocks. \n     /only  => Compose nested blocks as blocks containing their values. \n     /into  => Put results in out block, instead of creating a new block. \n         out   [any-block!]  => Target block for results, when /into is used. \n" },
  ['construct'] = { description = "\nUSAGE:\n      construct block /with object /only\nARGUMENTS:\n     block   [block!] \n\nREFINEMENTS:\n     /with \n         object   [object!] \n     /only \n" },
  ['context'] = { description = "\nUSAGE:\n      context spec\nARGUMENTS:\n     spec   [block!] \n\nREFINEMENTS:\n" },
  ['context?'] = { description = "\nUSAGE:\n      context? word\n\nDESCRIPTION:\n      Returns the context in which a word is bound. \n      context? is of type: native! \n\nARGUMENTS:\n     word   [any-word!]  => Word to check. \n\nREFINEMENTS:\n" },
  ['continue'] = { description = "\nUSAGE:\n      continue \n\nDESCRIPTION:\n      Throws control back to top of loop. \n      continue is of type: native! \n\nARGUMENTS:\n\nREFINEMENTS:\n" },
  ['copy'] = { description = "\nUSAGE:\n      copy value /part length /deep /types kind\n\nDESCRIPTION:\n      Returns a copy of a non-scalar value. \n      copy is of type: action! \n\nARGUMENTS:\n     value   [series! any-object! bitset! map!] \n\nREFINEMENTS:\n     /part  => Limit the length of the result. \n         length   [number! series! pair!] \n     /deep  => Copy nested values. \n     /types  => Copy only specific types of non-scalar values. \n         kind   [datatype!] \n" },
  ['cos'] = { description = "\nUSAGE:\n      cos angle\n\nDESCRIPTION:\n      Returns the trigonometric cosine. \n      cos is of type: function! \n\nARGUMENTS:\n     angle   [float!]  => Angle in radians. \n\nREFINEMENTS:\n" },
  ['cosine'] = { description = "\nUSAGE:\n      cosine angle /radians\n\nDESCRIPTION:\n      Returns the trigonometric cosine. \n      cosine is of type: native! \n\nARGUMENTS:\n     angle   [number!] \n\nREFINEMENTS:\n     /radians  => Angle is specified in radians. \n" },
  ['create-dir'] = { description = "\nUSAGE:\n      create-dir path\nARGUMENTS:\n     path   [file!] \n\nREFINEMENTS:\n" },
  ['datatype?'] = { description = "\nUSAGE:\n      datatype? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      datatype? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['debase'] = { description = "\nUSAGE:\n      debase value /base base-value\n\nDESCRIPTION:\n      Decodes binary-coded string (BASE-64 default) to binary value. \n      debase is of type: native! \n\nARGUMENTS:\n     value   [string!]  => The string to decode. \n\nREFINEMENTS:\n     /base  => Binary base to use. \n         base-value   [integer!]  => The base to convert from: 64, 16, or 2. \n" },
  ['dehex'] = { description = "\nUSAGE:\n      dehex value\n\nDESCRIPTION:\n      Converts URL-style hex encoded (%xx) strings. \n      dehex is of type: native! \n\nARGUMENTS:\n     value   [string! file!] \n\nREFINEMENTS:\n" },
  ['difference'] = { description = "\nUSAGE:\n      difference set1 set2 /case /skip size\n\nDESCRIPTION:\n      Returns the special difference of two data sets. \n      difference is of type: native! \n\nARGUMENTS:\n     set1   [block! hash! string! bitset! typeset!] \n     set2   [block! hash! string! bitset! typeset!] \n\nREFINEMENTS:\n     /case  => Use case-sensitive comparison. \n     /skip  => Treat the series as fixed size records. \n         size   [integer!] \n" },
  ['dir'] = { description = "\nUSAGE:\n      dir 'dir\nARGUMENTS:\n     'dir   [any-type!] \n\nREFINEMENTS:\n" },
  ['dir?'] = { description = "\nUSAGE:\n      dir? file\nARGUMENTS:\n     file   [file! url!] \n\nREFINEMENTS:\n" },
  ['dirize'] = { description = "\nUSAGE:\n      dirize path\n\nDESCRIPTION:\n      Returns a copy of the path turned into a directory. \n      dirize is of type: function! \n\nARGUMENTS:\n     path   [file! string! url!] \n\nREFINEMENTS:\n" },
  ['divide'] = { description = "\nUSAGE:\n      divide value1 value2\n\nDESCRIPTION:\n      Returns the quotient of two values. \n      divide is of type: action! \n\nARGUMENTS:\n     value1   [number! char! pair! tuple! vector! time!]  => The dividend (numerator). \n     value2   [number! char! pair! tuple! vector! time!]  => The divisor (denominator). \n\nREFINEMENTS:\n" },
  ['do'] = { description = "\nUSAGE:\n      do value /expand /args arg /next position\n\nDESCRIPTION:\n      Evaluates a value, returning the last evaluation result. \n      do is of type: native! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n     /expand  => Expand directives before evaluation. \n     /args  => If value is a script, this will set its system/script/args. \n         arg  => Args passed to a script (normally a string). \n     /next  => Do next expression only, return it, update block word. \n         position   [word!]  => Word updated with new block position. \n" },
  ['do-file'] = { description = "\nUSAGE:\n      do-file file\nARGUMENTS:\n     file   [file!] \n\nREFINEMENTS:\n" },
  ['does'] = { description = "\nUSAGE:\n      does body\n\nDESCRIPTION:\n      Defines a function with no arguments or local variables. \n      does is of type: native! \n\nARGUMENTS:\n     body   [block!] \n\nREFINEMENTS:\n" },
  ['dump-reactions'] = { description = "\nUSAGE:\n      dump-reactions \n\nDESCRIPTION:\n      Output all the current reactive relations for debugging purpose. \n      dump-reactions is of type: function! \n\nARGUMENTS:\n\nREFINEMENTS:\n" },
  ['either'] = { description = "\nUSAGE:\n      either cond true-blk false-blk\n\nDESCRIPTION:\n      If conditional expression is true, eval true-block; else eval false-blk. \n      either is of type: native! \n\nARGUMENTS:\n     cond   [any-type!] \n     true-blk   [block!] \n     false-blk   [block!] \n\nREFINEMENTS:\n" },
  ['email?'] = { description = "\nUSAGE:\n      email? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      email? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['empty?'] = { description = "\nUSAGE:\n      empty? series\n\nDESCRIPTION:\n      Returns true if a series is at its tail. \n      empty? is of type: function! \n\nARGUMENTS:\n     series   [series! none!] \n\nREFINEMENTS:\n" },
  ['enbase'] = { description = "\nUSAGE:\n      enbase value /base base-value\n\nDESCRIPTION:\n      Encodes a string into a binary-coded string (BASE-64 default). \n      enbase is of type: native! \n\nARGUMENTS:\n     value   [binary! string!]  => If string, will be UTF8 encoded. \n\nREFINEMENTS:\n     /base  => Binary base to use. \n         base-value   [integer!]  => The base to convert from: 64, 16, or 2. \n" },
  ['equal?'] = { description = "\nUSAGE:\n      equal? value1 value2\n\nDESCRIPTION:\n      Returns TRUE if two values are equal. \n      equal? is of type: native! \n\nARGUMENTS:\n     value1   [any-type!] \n     value2   [any-type!] \n\nREFINEMENTS:\n" },
  ['error?'] = { description = "\nUSAGE:\n      error? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      error? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['eval-set-path'] = { description = "\nUSAGE:\n      eval-set-path value1\nARGUMENTS:\n     value1 \n\nREFINEMENTS:\n" },
  ['even?'] = { description = "\nUSAGE:\n      even? number\n\nDESCRIPTION:\n      Returns true if the number is evenly divisible by 2. \n      even? is of type: action! \n\nARGUMENTS:\n     number   [number! char!] \n\nREFINEMENTS:\n" },
  ['exclude'] = { description = "\nUSAGE:\n      exclude set1 set2 /case /skip size\n\nDESCRIPTION:\n      Returns the first data set less the second data set. \n      exclude is of type: native! \n\nARGUMENTS:\n     set1   [block! hash! string! bitset! typeset!] \n     set2   [block! hash! string! bitset! typeset!] \n\nREFINEMENTS:\n     /case  => Use case-sensitive comparison. \n     /skip  => Treat the series as fixed size records. \n         size   [integer!] \n" },
  ['exists?'] = { description = "\nUSAGE:\n      exists? path\nARGUMENTS:\n     path   [file!] \n\nREFINEMENTS:\n" },
  ['exit'] = { description = "\nUSAGE:\n      exit \n\nDESCRIPTION:\n      Exits a function, returning no value. \n      exit is of type: native! \n\nARGUMENTS:\n\nREFINEMENTS:\n" },
  ['exp'] = { description = "\nUSAGE:\n      exp value\n\nDESCRIPTION:\n      Raises E (the base of natural logarithm) to the power specified. \n      exp is of type: native! \n\nARGUMENTS:\n     value   [number!] \n\nREFINEMENTS:\n" },
  ['expand'] = { description = "\nUSAGE:\n      expand blk\n\nDESCRIPTION:\n      Preprocess the argument block and display the output (console only). \n      expand is of type: function! \n\nARGUMENTS:\n     blk   [block!]  => Block to expand. \n\nREFINEMENTS:\n" },
  ['expand-directives'] = { description = "\nUSAGE:\n      expand-directives code /clean\n\nDESCRIPTION:\n      Invokes the preprocessor on argument list, modifying and returning it. \n      expand-directives is of type: function! \n\nARGUMENTS:\n     code   [block! paren!]  => List of Red values to preprocess. \n\nREFINEMENTS:\n     /clean  => Clear all previously created macros and words. \n" },
  ['extend'] = { description = "\nUSAGE:\n      extend obj spec /case\n\nDESCRIPTION:\n      Extend an object or map value with list of key and value pairs. \n      extend is of type: native! \n\nARGUMENTS:\n     obj   [object! map!] \n     spec   [block! hash! map!] \n\nREFINEMENTS:\n     /case  => Use case-sensitive comparison. \n" },
  ['extract'] = { description = "\nUSAGE:\n      extract series width /index pos /into output\n\nDESCRIPTION:\n      Extracts a value from a series at regular intervals. \n      extract is of type: function! \n\nARGUMENTS:\n     series   [series!] \n     width   [integer!]  => Size of each entry (the skip). \n\nREFINEMENTS:\n     /index  => Extract from an offset position. \n         pos   [integer!]  => The position. \n     /into  => Provide an output series instead of creating a new one. \n         output   [series!]  => Output series. \n" },
  ['extract-boot-args'] = { description = "\nUSAGE:\n      extract-boot-args \n\nDESCRIPTION:\n      Process command-line arguments and store values in system/options (internal usage). \n      extract-boot-args is of type: function! \n\nARGUMENTS:\n\nREFINEMENTS:\n" },
  ['fetch-help'] = { description = "\nUSAGE:\n      fetch-help word\n\nDESCRIPTION:\n      Display helping information about words and other values. \n      fetch-help is of type: function! \n\nARGUMENTS:\n     word   [any-type!]  => Word you are looking for. \n\nREFINEMENTS:\n" },
  ['fifth'] = { description = "\nUSAGE:\n      fifth s\n\nDESCRIPTION:\n      Returns the fifth value in a series. \n      fifth is of type: function! \n\nARGUMENTS:\n     s   [series! tuple!] \n\nREFINEMENTS:\n" },
  ['file?'] = { description = "\nUSAGE:\n      file? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      file? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['find'] = { description = "\nUSAGE:\n      find series value /part length /only /case /same /any /with wild /skip size /last /reverse /tail /match\n\nDESCRIPTION:\n      Returns the series where a value is found, or NONE. \n      find is of type: action! \n\nARGUMENTS:\n     series   [series! bitset! typeset! any-object! map! none!] \n     value   [any-type!] \n\nREFINEMENTS:\n     /part  => Limit the length of the search. \n         length   [number! series!] \n     /only  => Treat a series search value as a single value. \n     /case  => Perform a case-sensitive search. \n     /same  => Use \"same?\" as comparator. \n     /any  => TBD: Use * and ? wildcards in string searches. \n     /with  => TBD: Use custom wildcards in place of * and ?. \n         wild   [string!] \n     /skip  => Treat the series as fixed size records. \n         size   [integer!] \n     /last  => Find the last occurrence of value, from the tail. \n     /reverse  => Find the last occurrence of value, from the current index. \n     /tail  => Return the tail of the match found, rather than the head. \n     /match  => Match at current index only and return tail of match. \n" },
  ['first'] = { description = "\nUSAGE:\n      first s\n\nDESCRIPTION:\n      Returns the first value in a series. \n      first is of type: function! \n\nARGUMENTS:\n     s   [series! tuple! pair! time!] \n\nREFINEMENTS:\n" },
  ['flip-exe-flag'] = { description = "\nUSAGE:\n      flip-exe-flag path\n\nDESCRIPTION:\n      Flip the sub-system for the red.exe between console and GUI modes (Windows only). \n      flip-exe-flag is of type: function! \n\nARGUMENTS:\n     path   [file!]  => Path to the red.exe. \n\nREFINEMENTS:\n" },
  ['float?'] = { description = "\nUSAGE:\n      float? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      float? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['forall'] = { description = "\nUSAGE:\n      forall 'word body\n\nDESCRIPTION:\n      Evaluates body for all values in a series. \n      forall is of type: native! \n\nARGUMENTS:\n     'word   [word!]  => Word referring to series to iterate over. \n     body   [block!] \n\nREFINEMENTS:\n" },
  ['foreach'] = { description = "\nUSAGE:\n      foreach 'word series body\n\nDESCRIPTION:\n      Evaluates body for each value in a series. \n      foreach is of type: native! \n\nARGUMENTS:\n     'word   [word! block!]  => Word, or words, to set on each iteration. \n     series   [series!] \n     body   [block!] \n\nREFINEMENTS:\n" },
  ['forever'] = { description = "\nUSAGE:\n      forever body\n\nDESCRIPTION:\n      Evaluates body repeatedly forever. \n      forever is of type: native! \n\nARGUMENTS:\n     body   [block!] \n\nREFINEMENTS:\n" },
  ['form'] = { description = "\nUSAGE:\n      form value /part limit\n\nDESCRIPTION:\n      Returns a user-friendly string representation of a value. \n      form is of type: action! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n     /part  => Limit the length of the result. \n         limit   [integer!] \n" },
  ['fourth'] = { description = "\nUSAGE:\n      fourth s\n\nDESCRIPTION:\n      Returns the fourth value in a series. \n      fourth is of type: function! \n\nARGUMENTS:\n     s   [series! tuple!] \n\nREFINEMENTS:\n" },
  ['func'] = { description = "\nUSAGE:\n      func spec body\n\nDESCRIPTION:\n      Defines a function with a given spec and body. \n      func is of type: native! \n\nARGUMENTS:\n     spec   [block!] \n     body   [block!] \n\nREFINEMENTS:\n" },
  ['function'] = { description = "\nUSAGE:\n      function spec body /extern\n\nDESCRIPTION:\n      Defines a function, making all words found in body local. \n      function is of type: native! \n\nARGUMENTS:\n     spec   [block!] \n     body   [block!] \n\nREFINEMENTS:\n     /extern  => Exclude words that follow this refinement. \n" },
  ['function?'] = { description = "\nUSAGE:\n      function? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      function? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['get'] = { description = "\nUSAGE:\n      get word /any /case\n\nDESCRIPTION:\n      Returns the value a word refers to. \n      get is of type: native! \n\nARGUMENTS:\n     word   [word! path!] \n\nREFINEMENTS:\n     /any  => If word has no value, return UNSET rather than causing an error. \n     /case  => Use case-sensitive comparison (path only). \n" },
  ['get-api-data'] = { description = "\nUSAGE:\n      get-api-data \nARGUMENTS:\n\nREFINEMENTS:\n" },
  ['get-current-dir'] = { description = "\nUSAGE:\n      get-current-dir \nARGUMENTS:\n\nREFINEMENTS:\n" },
  ['get-env'] = { description = "\nUSAGE:\n      get-env var\n\nDESCRIPTION:\n      Returns the value of an OS environment variable (for current process). \n      get-env is of type: native! \n\nARGUMENTS:\n     var   [any-string! any-word!]  => Variable to get. \n\nREFINEMENTS:\n" },
  ['get-path?'] = { description = "\nUSAGE:\n      get-path? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      get-path? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['get-word?'] = { description = "\nUSAGE:\n      get-word? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      get-word? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['greater-or-equal?'] = { description = "\nUSAGE:\n      greater-or-equal? value1 value2\n\nDESCRIPTION:\n      Returns TRUE if the first value is greater than or equal to the second. \n      greater-or-equal? is of type: native! \n\nARGUMENTS:\n     value1   [any-type!] \n     value2   [any-type!] \n\nREFINEMENTS:\n" },
  ['greater?'] = { description = "\nUSAGE:\n      greater? value1 value2\n\nDESCRIPTION:\n      Returns TRUE if the first value is greater than the second. \n      greater? is of type: native! \n\nARGUMENTS:\n     value1   [any-type!] \n     value2   [any-type!] \n\nREFINEMENTS:\n" },
  ['halt'] = { description = "\nUSAGE:\n      halt \nARGUMENTS:\n\nREFINEMENTS:\n" },
  ['handle?'] = { description = "\nUSAGE:\n      handle? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      handle? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['has'] = { description = "\nUSAGE:\n      has vars body\n\nDESCRIPTION:\n      Defines a function with local variables, but no arguments. \n      has is of type: native! \n\nARGUMENTS:\n     vars   [block!] \n     body   [block!] \n\nREFINEMENTS:\n" },
  ['hash?'] = { description = "\nUSAGE:\n      hash? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      hash? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['head'] = { description = "\nUSAGE:\n      head series\n\nDESCRIPTION:\n      Returns a series at its first index. \n      head is of type: action! \n\nARGUMENTS:\n     series   [series!] \n\nREFINEMENTS:\n" },
  ['head?'] = { description = "\nUSAGE:\n      head? series\n\nDESCRIPTION:\n      Returns true if a series is at its first index. \n      head? is of type: action! \n\nARGUMENTS:\n     series   [series!] \n\nREFINEMENTS:\n" },
  ['help'] = { description = "\nUSAGE:\n      help 'word\n\nDESCRIPTION:\n      Display helping information about words and other values. \n      help is of type: function! \n\nARGUMENTS:\n     'word   [any-type!]  => Word you are looking for. \n\nREFINEMENTS:\n" },
  ['if'] = { description = "\nUSAGE:\n      if cond then-blk\n\nDESCRIPTION:\n      If conditional expression is TRUE, evaluate block; else return NONE. \n      if is of type: native! \n\nARGUMENTS:\n     cond   [any-type!] \n     then-blk   [block!] \n\nREFINEMENTS:\n" },
  ['image?'] = { description = "\nUSAGE:\n      image? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      image? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['immediate?'] = { description = "\nUSAGE:\n      immediate? value\n\nDESCRIPTION:\n      Returns true if the value is any type of immediate. \n      immediate? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['in'] = { description = "\nUSAGE:\n      in object word\nARGUMENTS:\n     object   [any-object!] \n     word   [any-word!] \n\nREFINEMENTS:\n" },
  ['index?'] = { description = "\nUSAGE:\n      index? series\n\nDESCRIPTION:\n      Returns the current index of series relative to the head, or of word in a context. \n      index? is of type: action! \n\nARGUMENTS:\n     series   [series! word!] \n\nREFINEMENTS:\n" },
  ['input'] = { description = "\nUSAGE:\n      input \nARGUMENTS:\n\nREFINEMENTS:\n" },
  ['insert'] = { description = "\nUSAGE:\n      insert series value /part length /only /dup count\n\nDESCRIPTION:\n      Inserts value(s) at series index; returns series past the insertion. \n      insert is of type: action! \n\nARGUMENTS:\n     series   [series! bitset! map!] \n     value   [any-type!] \n\nREFINEMENTS:\n     /part  => Limit the number of values inserted. \n         length   [number! series!] \n     /only  => Insert block types as single values (overrides /part). \n     /dup  => Duplicate the inserted values. \n         count   [number!] \n" },
  ['integer?'] = { description = "\nUSAGE:\n      integer? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      integer? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['intersect'] = { description = "\nUSAGE:\n      intersect set1 set2 /case /skip size\n\nDESCRIPTION:\n      Returns the intersection of two data sets. \n      intersect is of type: native! \n\nARGUMENTS:\n     set1   [block! hash! string! bitset! typeset!] \n     set2   [block! hash! string! bitset! typeset!] \n\nREFINEMENTS:\n     /case  => Use case-sensitive comparison. \n     /skip  => Treat the series as fixed size records. \n         size   [integer!] \n" },
  ['is'] = { description = "\nUSAGE:\n      'field is  reaction\n\nDESCRIPTION:\n      Defines a reactive relation which result is assigned to a word. \n      is is of type: op! \n\nARGUMENTS:\n     'field   [set-word!]  => Set-word which will get set to the result of the reaction. \n     reaction   [block!]  => Reactive relation. \n\nREFINEMENTS:\n" },
  ['issue?'] = { description = "\nUSAGE:\n      issue? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      issue? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['keys-of'] = { description = "\nUSAGE:\n      keys-of value\n\nDESCRIPTION:\n      Returns the list of words of a value that supports reflection. \n      keys-of is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['last'] = { description = "\nUSAGE:\n      last s\n\nDESCRIPTION:\n      Returns the last value in a series. \n      last is of type: function! \n\nARGUMENTS:\n     s   [series!] \n\nREFINEMENTS:\n" },
  ['last-lf?'] = { description = "\nUSAGE:\n      last-lf? \nARGUMENTS:\n\nREFINEMENTS:\n" },
  ['length?'] = { description = "\nUSAGE:\n      length? series\n\nDESCRIPTION:\n      Returns the number of values in the series, from the current index to the tail. \n      length? is of type: action! \n\nARGUMENTS:\n     series   [series! bitset! map! tuple! none!] \n\nREFINEMENTS:\n" },
  ['lesser-or-equal?'] = { description = "\nUSAGE:\n      lesser-or-equal? value1 value2\n\nDESCRIPTION:\n      Returns TRUE if the first value is less than or equal to the second. \n      lesser-or-equal? is of type: native! \n\nARGUMENTS:\n     value1   [any-type!] \n     value2   [any-type!] \n\nREFINEMENTS:\n" },
  ['lesser?'] = { description = "\nUSAGE:\n      lesser? value1 value2\n\nDESCRIPTION:\n      Returns TRUE if the first value is less than the second. \n      lesser? is of type: native! \n\nARGUMENTS:\n     value1   [any-type!] \n     value2   [any-type!] \n\nREFINEMENTS:\n" },
  ['list-dir'] = { description = "\nUSAGE:\n      list-dir dir /col n\n\nDESCRIPTION:\n      Displays a list of files and directories from given folder or current one. \n      list-dir is of type: function! \n\nARGUMENTS:\n     dir   [any-type!]  => Folder to list. \n\nREFINEMENTS:\n     /col  => Forces the display in a given number of columns. \n         n   [integer!]  => Number of columns. \n" },
  ['list-env'] = { description = "\nUSAGE:\n      list-env \n\nDESCRIPTION:\n      Returns a map of OS environment variables (for current process). \n      list-env is of type: native! \n\nARGUMENTS:\n\nREFINEMENTS:\n" },
  ['lit-path?'] = { description = "\nUSAGE:\n      lit-path? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      lit-path? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['lit-word?'] = { description = "\nUSAGE:\n      lit-word? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      lit-word? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['ll'] = { description = "\nUSAGE:\n      ll 'dir\nARGUMENTS:\n     'dir   [any-type!] \n\nREFINEMENTS:\n" },
  ['load'] = { description = "\nUSAGE:\n      load source /header /all /trap /next position /part length /into out /as type\n\nDESCRIPTION:\n      Returns a value or block of values by reading and evaluating a source. \n      load is of type: function! \n\nARGUMENTS:\n     source   [file! url! string! binary!] \n\nREFINEMENTS:\n     /header  => TBD. \n     /all  => Load all values, returns a block. TBD: Don't evaluate Red header. \n     /trap  => Load all values, returns [[values] position error]. \n     /next  => Load the next value only, updates source series word. \n         position   [word!]  => Word updated with new series position. \n     /part \n         length   [integer! string!] \n     /into  => Put results in out block, instead of creating a new block. \n         out   [block!]  => Target block for results. \n     /as  => Specify the type of data; use NONE to load as code. \n         type   [word! none!]  => E.g. json, html, jpeg, png, etc. \n" },
  ['log-10'] = { description = "\nUSAGE:\n      log-10 value\n\nDESCRIPTION:\n      Returns the base-10 logarithm. \n      log-10 is of type: native! \n\nARGUMENTS:\n     value   [number!] \n\nREFINEMENTS:\n" },
  ['log-2'] = { description = "\nUSAGE:\n      log-2 value\n\nDESCRIPTION:\n      Return the base-2 logarithm. \n      log-2 is of type: native! \n\nARGUMENTS:\n     value   [number!] \n\nREFINEMENTS:\n" },
  ['log-e'] = { description = "\nUSAGE:\n      log-e value\n\nDESCRIPTION:\n      Returns the natural (base-E) logarithm of the given value. \n      log-e is of type: native! \n\nARGUMENTS:\n     value   [number!] \n\nREFINEMENTS:\n" },
  ['logic?'] = { description = "\nUSAGE:\n      logic? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      logic? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['loop'] = { description = "\nUSAGE:\n      loop count body\n\nDESCRIPTION:\n      Evaluates body a number of times. \n      loop is of type: native! \n\nARGUMENTS:\n     count   [integer!] \n     body   [block!] \n\nREFINEMENTS:\n" },
  ['lowercase'] = { description = "\nUSAGE:\n      lowercase string /part limit\n\nDESCRIPTION:\n      Converts string of characters to lowercase. \n      lowercase is of type: native! \n\nARGUMENTS:\n     string   [any-string! char!] \n\nREFINEMENTS:\n     /part  => Limits to a given length or position. \n         limit   [number! any-string!] \n" },
  ['ls'] = { description = "\nUSAGE:\n      ls 'dir\nARGUMENTS:\n     'dir   [any-type!] \n\nREFINEMENTS:\n" },
  ['make'] = { description = "\nUSAGE:\n      make type spec\n\nDESCRIPTION:\n      Returns a new value made from a spec for that value's type. \n      make is of type: action! \n\nARGUMENTS:\n     type   [any-type!]  => The datatype, an example or prototype value. \n     spec   [any-type!]  => The specification of the new value. \n\nREFINEMENTS:\n" },
  ['make-dir'] = { description = "\nUSAGE:\n      make-dir path /deep\n\nDESCRIPTION:\n      Creates the specified directory. No error if already exists. \n      make-dir is of type: function! \n\nARGUMENTS:\n     path   [file!] \n\nREFINEMENTS:\n     /deep  => Create subdirectories too. \n" },
  ['map?'] = { description = "\nUSAGE:\n      map? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      map? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['math'] = { description = "\nUSAGE:\n      math body /safe\n\nDESCRIPTION:\n      Evaluates a block using math precedence rules, returning the last result. \n      math is of type: function! \n\nARGUMENTS:\n     body   [block!]  => Block to evaluate. \n\nREFINEMENTS:\n     /safe  => Returns NONE on error. \n" },
  ['max'] = { description = "\nUSAGE:\n      max value1 value2\n\nDESCRIPTION:\n      Returns the greater of the two values. \n      max is of type: native! \n\nARGUMENTS:\n     value1   [number! series! char! time!] \n     value2   [number! series! char! time!] \n\nREFINEMENTS:\n" },
  ['min'] = { description = "\nUSAGE:\n      min value1 value2\n\nDESCRIPTION:\n      Returns the lesser of the two values. \n      min is of type: native! \n\nARGUMENTS:\n     value1   [number! series! char! time!] \n     value2   [number! series! char! time!] \n\nREFINEMENTS:\n" },
  ['mod'] = { description = "\nUSAGE:\n      mod a b\n\nDESCRIPTION:\n      Compute a nonnegative remainder of A divided by B. \n      mod is of type: function! \n\nARGUMENTS:\n     a   [number! char! pair! tuple! vector! time!] \n     b   [number! char! pair! tuple! vector! time!]  => Must be nonzero. \n\nREFINEMENTS:\n" },
  ['modify'] = { description = "\nUSAGE:\n      modify target field value /case\n\nDESCRIPTION:\n      Change mode for target aggregate value. \n      modify is of type: action! \n\nARGUMENTS:\n     target   [object! series!] \n     field   [word!] \n     value   [any-type!] \n\nREFINEMENTS:\n     /case  => Perform a case-sensitive lookup. \n" },
  ['modulo'] = { description = "\nUSAGE:\n      modulo a b\n\nDESCRIPTION:\n      Wrapper for MOD that handles errors like REMAINDER. Negligible values (compared to A and B) are rounded to zero. \n      modulo is of type: function! \n\nARGUMENTS:\n     a   [number! char! pair! tuple! vector! time!] \n     b   [number! char! pair! tuple! vector! time!] \n\nREFINEMENTS:\n" },
  ['mold'] = { description = "\nUSAGE:\n      mold value /only /all /flat /part limit\n\nDESCRIPTION:\n      Returns a source format string representation of a value. \n      mold is of type: action! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n     /only  => Exclude outer brackets if value is a block. \n     /all  => TBD: Return value in loadable format. \n     /flat  => TBD: Exclude all indentation. \n     /part  => Limit the length of the result. \n         limit   [integer!] \n" },
  ['move'] = { description = "\nUSAGE:\n      move origin target /part length\n\nDESCRIPTION:\n      Moves one or more elements from one series to another position or series. \n      move is of type: action! \n\nARGUMENTS:\n     origin   [series!] \n     target   [series!] \n\nREFINEMENTS:\n     /part  => Limit the number of values inserted. \n         length   [integer!] \n" },
  ['multiply'] = { description = "\nUSAGE:\n      multiply value1 value2\n\nDESCRIPTION:\n      Returns the product of two values. \n      multiply is of type: action! \n\nARGUMENTS:\n     value1   [number! char! pair! tuple! vector! time!] \n     value2   [number! char! pair! tuple! vector! time!] \n\nREFINEMENTS:\n" },
  ['NaN?'] = { description = "\nUSAGE:\n      NaN? value\n\nDESCRIPTION:\n      Returns TRUE if the number is Not-a-Number. \n      NaN? is of type: native! \n\nARGUMENTS:\n     value   [number!] \n\nREFINEMENTS:\n" },
  ['native?'] = { description = "\nUSAGE:\n      native? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      native? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['negate'] = { description = "\nUSAGE:\n      negate number\n\nDESCRIPTION:\n      Returns the opposite (additive inverse) value. \n      negate is of type: action! \n\nARGUMENTS:\n     number   [number! bitset! pair! time!] \n\nREFINEMENTS:\n" },
  ['negative?'] = { description = "\nUSAGE:\n      negative? number\n\nDESCRIPTION:\n      Returns TRUE if the number is negative. \n      negative? is of type: native! \n\nARGUMENTS:\n     number   [number! time!] \n\nREFINEMENTS:\n" },
  ['new-line'] = { description = "\nUSAGE:\n      new-line position value /all /skip size\n\nDESCRIPTION:\n      Sets or clears the new-line marker within a block or paren. \n      new-line is of type: native! \n\nARGUMENTS:\n     position   [block! paren!]  => Position to change marker (modified). \n     value  => Set TRUE for newline. \n\nREFINEMENTS:\n     /all  => Set/clear marker to end of series. \n     /skip  => Set/clear marker periodically to the end of the series. \n         size   [integer!] \n" },
  ['new-line?'] = { description = "\nUSAGE:\n      new-line? position\n\nDESCRIPTION:\n      Returns the state of the new-line marker within a block or paren. \n      new-line? is of type: native! \n\nARGUMENTS:\n     position   [block! paren!]  => Position to change marker. \n\nREFINEMENTS:\n" },
  ['next'] = { description = "\nUSAGE:\n      next series\n\nDESCRIPTION:\n      Returns a series at the next index. \n      next is of type: action! \n\nARGUMENTS:\n     series   [series!] \n\nREFINEMENTS:\n" },
  ['none?'] = { description = "\nUSAGE:\n      none? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      none? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['normalize-dir'] = { description = "\nUSAGE:\n      normalize-dir dir\nARGUMENTS:\n     dir   [file! word! path!] \n\nREFINEMENTS:\n" },
  ['not'] = { description = "\nUSAGE:\n      not value\n\nDESCRIPTION:\n      Returns the boolean complement of a value. \n      not is of type: native! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['not-equal?'] = { description = "\nUSAGE:\n      not-equal? value1 value2\n\nDESCRIPTION:\n      Returns TRUE if two values are not equal. \n      not-equal? is of type: native! \n\nARGUMENTS:\n     value1   [any-type!] \n     value2   [any-type!] \n\nREFINEMENTS:\n" },
  ['now'] = { description = "\nUSAGE:\n      now  /year /month /day /time /zone /date /weekday /yearday /precise /utc\n\nDESCRIPTION:\n      Returns date and time. \n      now is of type: native! \n\nARGUMENTS:\n\nREFINEMENTS:\n     /year  => Returns year only. \n     /month  => Returns month only. \n     /day  => Returns day of the month only. \n     /time  => Returns time only. \n     /zone  => Returns time zone offset from UCT (GMT) only. \n     /date  => Returns date only. \n     /weekday  => Returns day of the week as integer (Monday is day 1). \n     /yearday  => Returns day of the year (Julian). \n     /precise  => High precision time. \n     /utc  => Universal time (no zone). \n" },
  ['number?'] = { description = "\nUSAGE:\n      number? value\n\nDESCRIPTION:\n      Returns true if the value is any type of number. \n      number? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['object'] = { description = "\nUSAGE:\n      object spec\nARGUMENTS:\n     spec   [block!] \n\nREFINEMENTS:\n" },
  ['object?'] = { description = "\nUSAGE:\n      object? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      object? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['odd?'] = { description = "\nUSAGE:\n      odd? number\n\nDESCRIPTION:\n      Returns true if the number has a remainder of 1 when divided by 2. \n      odd? is of type: action! \n\nARGUMENTS:\n     number   [number! char!] \n\nREFINEMENTS:\n" },
  ['offset?'] = { description = "\nUSAGE:\n      offset? series1 series2\n\nDESCRIPTION:\n      Returns the offset between two series positions. \n      offset? is of type: function! \n\nARGUMENTS:\n     series1   [series!] \n     series2   [series!] \n\nREFINEMENTS:\n" },
  ['on-parse-event'] = { description = "\nUSAGE:\n      on-parse-event event match? rule input stack\nARGUMENTS:\n     event   [word!]  => Trace events: push, pop, fetch, match, iterate, paren, end. \n     match?   [logic!]  => Result of last matching operation. \n     rule   [block!]  => Current rule at current position. \n     input   [series!]  => Input series at next position to match. \n     stack   [block!]  => Internal parse rules stack. \n\nREFINEMENTS:\n" },
  ['op?'] = { description = "\nUSAGE:\n      op? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      op? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['or'] = { description = "\nUSAGE:\n      value1 or  value2\n\nDESCRIPTION:\n      Returns the first value ORed with the second. \n      or is of type: op! \n\nARGUMENTS:\n     value1   [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n     value2   [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n\nREFINEMENTS:\n" },
  ['or~'] = { description = "\nUSAGE:\n      or~ value1 value2\n\nDESCRIPTION:\n      Returns the first value ORed with the second. \n      or~ is of type: action! \n\nARGUMENTS:\n     value1   [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n     value2   [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n\nREFINEMENTS:\n" },
  ['pad'] = { description = "\nUSAGE:\n      pad str n /left /with c\n\nDESCRIPTION:\n      Pad a string on right side with spaces. \n      pad is of type: function! \n\nARGUMENTS:\n     str   [string!]  => String to pad. \n     n   [integer!]  => Total size (in characters) of the new string. \n\nREFINEMENTS:\n     /left  => Pad the string on left side. \n     /with \n         c   [char!]  => Pad with char. \n" },
  ['pair?'] = { description = "\nUSAGE:\n      pair? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      pair? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['paren?'] = { description = "\nUSAGE:\n      paren? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      paren? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['parse'] = { description = "\nUSAGE:\n      parse input rules /case /part length /trace callback\nARGUMENTS:\n     input   [binary! any-block! any-string!] \n     rules   [block!] \n\nREFINEMENTS:\n     /case \n     /part \n         length   [number! series!] \n     /trace \n         callback   [function! [\n    event [word!] \n    match? [logic!] \n    rule [block!] \n    input [series!] \n    stack [block!] \n    return: [logic!]\n]] \n" },
  ['parse-trace'] = { description = "\nUSAGE:\n      parse-trace input rules /case /part limit\n\nDESCRIPTION:\n      Wrapper for parse/trace using the default event processor. \n      parse-trace is of type: function! \n\nARGUMENTS:\n     input   [series!] \n     rules   [block!] \n\nREFINEMENTS:\n     /case \n     /part \n         limit   [integer!] \n" },
  ['path?'] = { description = "\nUSAGE:\n      path? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      path? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['percent?'] = { description = "\nUSAGE:\n      percent? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      percent? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['pick'] = { description = "\nUSAGE:\n      pick series index\n\nDESCRIPTION:\n      Returns the series value at a given index. \n      pick is of type: action! \n\nARGUMENTS:\n     series   [series! bitset! pair! tuple! time!] \n     index   [scalar! any-string! any-word! block! logic! time!] \n\nREFINEMENTS:\n" },
  ['poke'] = { description = "\nUSAGE:\n      poke series index value\n\nDESCRIPTION:\n      Replaces the series value at a given index, and returns the new value. \n      poke is of type: action! \n\nARGUMENTS:\n     series   [series! bitset!] \n     index   [scalar! any-string! any-word! block! logic!] \n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['positive?'] = { description = "\nUSAGE:\n      positive? number\n\nDESCRIPTION:\n      Returns TRUE if the number is positive. \n      positive? is of type: native! \n\nARGUMENTS:\n     number   [number! time!] \n\nREFINEMENTS:\n" },
  ['power'] = { description = "\nUSAGE:\n      power number exponent\n\nDESCRIPTION:\n      Returns a number raised to a given power (exponent). \n      power is of type: action! \n\nARGUMENTS:\n     number   [number!]  => Base value. \n     exponent   [number!]  => The power (index) to raise the base value by. \n\nREFINEMENTS:\n" },
  ['prin'] = { description = "\nUSAGE:\n      prin value\n\nDESCRIPTION:\n      Outputs a value. \n      prin is of type: native! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['prin-out'] = { description = "\nUSAGE:\n      prin-out out data\nARGUMENTS:\n     out \n     data \n\nREFINEMENTS:\n" },
  ['print'] = { description = "\nUSAGE:\n      print value\n\nDESCRIPTION:\n      Outputs a value followed by a newline. \n      print is of type: native! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['print-out'] = { description = "\nUSAGE:\n      print-out out data\nARGUMENTS:\n     out \n     data \n\nREFINEMENTS:\n" },
  ['probe'] = { description = "\nUSAGE:\n      probe value\n\nDESCRIPTION:\n      Returns a value after printing its molded form. \n      probe is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['put'] = { description = "\nUSAGE:\n      put series key value /case\n\nDESCRIPTION:\n      Replaces the value following a key, and returns the new value. \n      put is of type: action! \n\nARGUMENTS:\n     series   [series! map! object!] \n     key   [scalar! any-string! any-word!] \n     value   [any-type!] \n\nREFINEMENTS:\n     /case  => Perform a case-sensitive search. \n" },
  ['pwd'] = { description = "\nUSAGE:\n      pwd \nARGUMENTS:\n\nREFINEMENTS:\n" },
  ['q'] = { description = "\nUSAGE:\n      q  /return status\n\nDESCRIPTION:\n      Stops evaluation and exits the program. \n      q is of type: function! \n\nARGUMENTS:\n\nREFINEMENTS:\n     /return \n         status   [integer!]  => Return an exit status. \n" },
  ['quit'] = { description = "\nUSAGE:\n      quit  /return status\n\nDESCRIPTION:\n      Stops evaluation and exits the program. \n      quit is of type: function! \n\nARGUMENTS:\n\nREFINEMENTS:\n     /return \n         status   [integer!]  => Return an exit status. \n" },
  ['quit-return'] = { description = "\nUSAGE:\n      quit-return status\n\nDESCRIPTION:\n      Stops evaluation and exits the program with a given status. \n      quit-return is of type: routine! \n\nARGUMENTS:\n     status   [integer!]  => Process termination value to return. \n\nREFINEMENTS:\n" },
  ['quote'] = { description = "\nUSAGE:\n      quote :value\nARGUMENTS:\n     :value \n\nREFINEMENTS:\n" },
  ['random'] = { description = "\nUSAGE:\n      random value /seed /secure /only\n\nDESCRIPTION:\n      Returns a random value of the same datatype; or shuffles series. \n      random is of type: action! \n\nARGUMENTS:\n     value  => Maximum value of result (modified when series). \n\nREFINEMENTS:\n     /seed  => Restart or randomize. \n     /secure  => TBD: Returns a cryptographically secure random number. \n     /only  => Pick a random value from a series. \n" },
  ['react'] = { description = "\nUSAGE:\n      react reaction /link objects /unlink src /later /with ctx\n\nDESCRIPTION:\n      Defines a new reactive relation between two or more objects. \n      react is of type: function! \n\nARGUMENTS:\n     reaction   [block! function!]  => Reactive relation. \n\nREFINEMENTS:\n     /link  => Link objects together using a reactive relation. \n         objects   [block!]  => Objects to link together. \n     /unlink  => Removes an existing reactive relation. \n         src   [word! object! block!]  => 'all word, or a reactor or a list of reactors. \n     /later  => Run the reaction on next change instead of now. \n     /with  => Specifies an optional face object (internal use). \n         ctx   [object! set-word! none!]  => Optional context for VID faces or target set-word. \n" },
  ['react?'] = { description = "\nUSAGE:\n      react? reactor field /target\n\nDESCRIPTION:\n      Returns a reactive relation if an object's field is a reactive source. \n      react? is of type: function! \n\nARGUMENTS:\n     reactor   [object!]  => Object to check. \n     field   [word!]  => Field to check. \n\nREFINEMENTS:\n     /target  => Check if it's a target instead of a source. \n" },
  ['read'] = { description = "\nUSAGE:\n      read source /part length /seek index /binary /lines /info /as encoding\n\nDESCRIPTION:\n      Read from a file, URL, or other port. \n      read is of type: action! \n\nARGUMENTS:\n     source   [file! url!] \n\nREFINEMENTS:\n     /part  => Partial read a given number of units (source relative). \n         length   [number!] \n     /seek  => Read from a specific position (source relative). \n         index   [number!] \n     /binary  => Preserves contents exactly. \n     /lines  => Convert to block of strings. \n     /info \n     /as  => Read with the specified encoding, default is 'UTF-8. \n         encoding   [word!] \n" },
  ['red-complete-file'] = { description = "\nUSAGE:\n      red-complete-file str\nARGUMENTS:\n     str   [string!] \n\nREFINEMENTS:\n" },
  ['red-complete-input'] = { description = "\nUSAGE:\n      red-complete-input str console?\nARGUMENTS:\n     str   [string!] \n     console?   [logic!] \n\nREFINEMENTS:\n" },
  ['red-complete-path'] = { description = "\nUSAGE:\n      red-complete-path str\nARGUMENTS:\n     str   [string!] \n\nREFINEMENTS:\n" },
  ['reduce'] = { description = "\nUSAGE:\n      reduce value /into out\n\nDESCRIPTION:\n      Returns a copy of a block, evaluating all expressions. \n      reduce is of type: native! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n     /into  => Put results in out block, instead of creating a new block. \n         out   [any-block!]  => Target block for results, when /into is used. \n" },
  ['refinement?'] = { description = "\nUSAGE:\n      refinement? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      refinement? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['reflect'] = { description = "\nUSAGE:\n      reflect value field\n\nDESCRIPTION:\n      Returns internal details about a value via reflection. \n      reflect is of type: action! \n\nARGUMENTS:\n     value   [any-type!] \n     field   [word!]  => spec, body, words, etc. Each datatype defines its own reflectors. \n\nREFINEMENTS:\n" },
  ['rejoin'] = { description = "\nUSAGE:\n      rejoin block\n\nDESCRIPTION:\n      Reduces and joins a block of values.. \n      rejoin is of type: function! \n\nARGUMENTS:\n     block   [block!]  => Values to reduce and join. \n\nREFINEMENTS:\n" },
  ['remainder'] = { description = "\nUSAGE:\n      remainder value1 value2\n\nDESCRIPTION:\n      Returns what is left over when one value is divided by another. \n      remainder is of type: action! \n\nARGUMENTS:\n     value1   [number! char! pair! tuple! vector! time!] \n     value2   [number! char! pair! tuple! vector! time!] \n\nREFINEMENTS:\n" },
  ['remove'] = { description = "\nUSAGE:\n      remove series /part length\n\nDESCRIPTION:\n      Returns the series at the same index after removing a value. \n      remove is of type: action! \n\nARGUMENTS:\n     series   [series! bitset! none!] \n\nREFINEMENTS:\n     /part  => Removes a number of values, or values up to the given series index. \n         length   [number! char! series!] \n" },
  ['remove-each'] = { description = "\nUSAGE:\n      remove-each 'word data body\n\nDESCRIPTION:\n      Removes values for each block that returns true. \n      remove-each is of type: native! \n\nARGUMENTS:\n     'word   [word! block!]  => Word or block of words to set each time. \n     data   [series!]  => The series to traverse (modified). \n     body   [block!]  => Block to evaluate (return TRUE to remove). \n\nREFINEMENTS:\n" },
  ['repeat'] = { description = "\nUSAGE:\n      repeat 'word value body\n\nDESCRIPTION:\n      Evaluates body a number of times, tracking iteration count. \n      repeat is of type: native! \n\nARGUMENTS:\n     'word   [word!]  => Iteration counter; not local to loop. \n     value   [integer!]  => Number of times to evaluate body. \n     body   [block!] \n\nREFINEMENTS:\n" },
  ['repend'] = { description = "\nUSAGE:\n      repend series value /only\n\nDESCRIPTION:\n      Appends a reduced value to a series and returns the series head. \n      repend is of type: function! \n\nARGUMENTS:\n     series   [series!] \n     value \n\nREFINEMENTS:\n     /only  => Appends a block value as a block. \n" },
  ['replace'] = { description = "\nUSAGE:\n      replace series pattern value /all\nARGUMENTS:\n     series   [series!] \n     pattern \n     value \n\nREFINEMENTS:\n     /all \n" },
  ['return'] = { description = "\nUSAGE:\n      return value\n\nDESCRIPTION:\n      Returns a value from a function. \n      return is of type: native! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['reverse'] = { description = "\nUSAGE:\n      reverse series /part length\n\nDESCRIPTION:\n      Reverses the order of elements; returns at same position. \n      reverse is of type: action! \n\nARGUMENTS:\n     series   [series! pair! tuple!] \n\nREFINEMENTS:\n     /part  => Limits to a given length or position. \n         length   [number! series!] \n" },
  ['round'] = { description = "\nUSAGE:\n      round n /to scale /even /down /half-down /floor /ceiling /half-ceiling\n\nDESCRIPTION:\n      Returns the nearest integer. Halves round up (away from zero) by default. \n      round is of type: action! \n\nARGUMENTS:\n     n   [number! time! pair!] \n\nREFINEMENTS:\n     /to  => Return the nearest multiple of the scale parameter. \n         scale   [number!]  => Must be a non-zero value. \n     /even  => Halves round toward even results. \n     /down  => Round toward zero, ignoring discarded digits. (truncate). \n     /half-down  => Halves round toward zero. \n     /floor  => Round in negative direction. \n     /ceiling  => Round in positive direction. \n     /half-ceiling  => Halves round in positive direction. \n" },
  ['routine'] = { description = "\nUSAGE:\n      routine spec body\nARGUMENTS:\n     spec   [block!] \n     body   [block!] \n\nREFINEMENTS:\n" },
  ['routine?'] = { description = "\nUSAGE:\n      routine? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      routine? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['same?'] = { description = "\nUSAGE:\n      same? value1 value2\n\nDESCRIPTION:\n      Returns TRUE if two values have the same identity. \n      same? is of type: native! \n\nARGUMENTS:\n     value1   [any-type!] \n     value2   [any-type!] \n\nREFINEMENTS:\n" },
  ['save'] = { description = "\nUSAGE:\n      save where value /header header-data /all /length /as format\n\nDESCRIPTION:\n      Saves a value, block, or other data to a file, URL, binary, or string. \n      save is of type: function! \n\nARGUMENTS:\n     where   [file! url! string! binary! none!]  => Where to save. \n     value  => Value(s) to save. \n\nREFINEMENTS:\n     /header  => Provide a Red header block (or output non-code datatypes). \n         header-data   [block! object!] \n     /all  => TBD: Save in serialized format. \n     /length  => Save the length of the script content in the header. \n     /as  => Specify the format of data; use NONE to save as plain text. \n         format   [word! none!]  => E.g. json, html, jpeg, png, redbin etc. \n" },
  ['scalar?'] = { description = "\nUSAGE:\n      scalar? value\n\nDESCRIPTION:\n      Returns true if the value is any type of scalar. \n      scalar? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['second'] = { description = "\nUSAGE:\n      second s\n\nDESCRIPTION:\n      Returns the second value in a series. \n      second is of type: function! \n\nARGUMENTS:\n     s   [series! tuple! pair! time!] \n\nREFINEMENTS:\n" },
  ['select'] = { description = "\nUSAGE:\n      select series value /part length /only /case /same /any /with wild /skip size /last /reverse\n\nDESCRIPTION:\n      Find a value in a series and return the next value, or NONE. \n      select is of type: action! \n\nARGUMENTS:\n     series   [series! any-object! map! none!] \n     value   [any-type!] \n\nREFINEMENTS:\n     /part  => Limit the length of the search. \n         length   [number! series!] \n     /only  => Treat a series search value as a single value. \n     /case  => Perform a case-sensitive search. \n     /same  => Use \"same?\" as comparator. \n     /any  => TBD: Use * and ? wildcards in string searches. \n     /with  => TBD: Use custom wildcards in place of * and ?. \n         wild   [string!] \n     /skip  => Treat the series as fixed size records. \n         size   [integer!] \n     /last  => Find the last occurrence of value, from the tail. \n     /reverse  => Find the last occurrence of value, from the current index. \n" },
  ['series?'] = { description = "\nUSAGE:\n      series? value\n\nDESCRIPTION:\n      Returns true if the value is any type of series. \n      series? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['set'] = { description = "\nUSAGE:\n      set word value /any /case /only /some\n\nDESCRIPTION:\n      Sets the value(s) one or more words refer to. \n      set is of type: native! \n\nARGUMENTS:\n     word   [any-word! block! object! path! map!]  => Word, object, map or block of words to set. \n     value   [any-type!]  => Value or block of values to assign to words. \n\nREFINEMENTS:\n     /any  => Allow UNSET as a value rather than causing an error. \n     /case  => Use case-sensitive comparison (path only). \n     /only  => Block or object value argument is set as a single value. \n     /some  => None values in a block or object value argument, are not set. \n" },
  ['set-current-dir'] = { description = "\nUSAGE:\n      set-current-dir path\nARGUMENTS:\n     path   [string!] \n\nREFINEMENTS:\n" },
  ['set-env'] = { description = "\nUSAGE:\n      set-env var value\n\nDESCRIPTION:\n      Sets the value of an operating system environment variable (for current process). \n      set-env is of type: native! \n\nARGUMENTS:\n     var   [any-string! any-word!]  => Variable to set. \n     value   [string! none!]  => Value to set, or NONE to unset it. \n\nREFINEMENTS:\n" },
  ['set-path?'] = { description = "\nUSAGE:\n      set-path? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      set-path? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['set-quiet'] = { description = "\nUSAGE:\n      set-quiet word value\n\nDESCRIPTION:\n      Set an object's field to a value without triggering object's events. \n      set-quiet is of type: routine! \n\nARGUMENTS:\n     word   [word!] \n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['set-word?'] = { description = "\nUSAGE:\n      set-word? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      set-word? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['shift'] = { description = "\nUSAGE:\n      shift data bits /left /logical\n\nDESCRIPTION:\n      Perform a bit shift operation. Right shift (decreasing) by default. \n      shift is of type: native! \n\nARGUMENTS:\n     data   [integer!] \n     bits   [integer!] \n\nREFINEMENTS:\n     /left  => Shift bits to the left (increasing). \n     /logical  => Use logical shift (unsigned, fill with zero). \n" },
  ['shift-left'] = { description = "\nUSAGE:\n      shift-left data bits\nARGUMENTS:\n     data   [integer!] \n     bits   [integer!] \n\nREFINEMENTS:\n" },
  ['shift-logical'] = { description = "\nUSAGE:\n      shift-logical data bits\nARGUMENTS:\n     data   [integer!] \n     bits   [integer!] \n\nREFINEMENTS:\n" },
  ['shift-right'] = { description = "\nUSAGE:\n      shift-right data bits\nARGUMENTS:\n     data   [integer!] \n     bits   [integer!] \n\nREFINEMENTS:\n" },
  ['sign?'] = { description = "\nUSAGE:\n      sign? number\n\nDESCRIPTION:\n      Returns sign of N as 1, 0, or -1 (to use as a multiplier). \n      sign? is of type: native! \n\nARGUMENTS:\n     number   [number! time!] \n\nREFINEMENTS:\n" },
  ['sin'] = { description = "\nUSAGE:\n      sin angle\n\nDESCRIPTION:\n      Returns the trigonometric sine. \n      sin is of type: function! \n\nARGUMENTS:\n     angle   [float!]  => Angle in radians. \n\nREFINEMENTS:\n" },
  ['sine'] = { description = "\nUSAGE:\n      sine angle /radians\n\nDESCRIPTION:\n      Returns the trigonometric sine. \n      sine is of type: native! \n\nARGUMENTS:\n     angle   [number!] \n\nREFINEMENTS:\n     /radians  => Angle is specified in radians. \n" },
  ['skip'] = { description = "\nUSAGE:\n      skip series offset\n\nDESCRIPTION:\n      Returns the series relative to the current index. \n      skip is of type: action! \n\nARGUMENTS:\n     series   [series!] \n     offset   [integer! pair!] \n\nREFINEMENTS:\n" },
  ['sort'] = { description = "\nUSAGE:\n      sort series /case /skip size /compare comparator /part length /all /reverse /stable\n\nDESCRIPTION:\n      Sorts a series (modified); default sort order is ascending. \n      sort is of type: action! \n\nARGUMENTS:\n     series   [series!] \n\nREFINEMENTS:\n     /case  => Perform a case-sensitive sort. \n     /skip  => Treat the series as fixed size records. \n         size   [integer!] \n     /compare  => Comparator offset, block or function. \n         comparator   [integer! block! any-function!] \n     /part  => Sort only part of a series. \n         length   [number! series!] \n     /all  => Compare all fields. \n     /reverse  => Reverse sort order. \n     /stable  => Stable sorting. \n" },
  ['source'] = { description = "\nUSAGE:\n      source 'func-name\n\nDESCRIPTION:\n      Print the source of a function. \n      source is of type: function! \n\nARGUMENTS:\n     'func-name   [any-word!]  => The name of the function. \n\nREFINEMENTS:\n" },
  ['spec-of'] = { description = "\nUSAGE:\n      spec-of value\n\nDESCRIPTION:\n      Returns the spec of a value that supports reflection. \n      spec-of is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['split'] = { description = "\nUSAGE:\n      split series dlm\n\nDESCRIPTION:\n      Break a string series into pieces using the provided delimiters. \n      split is of type: function! \n\nARGUMENTS:\n     series   [any-string!] \n     dlm   [string! char! bitset!] \n\nREFINEMENTS:\n" },
  ['split-path'] = { description = "\nUSAGE:\n      split-path target\n\nDESCRIPTION:\n      Splits a file or URL path. Returns a block containing path and target. \n      split-path is of type: function! \n\nARGUMENTS:\n     target   [file! url!] \n\nREFINEMENTS:\n" },
  ['sqrt'] = { description = "\nUSAGE:\n      sqrt number\n\nDESCRIPTION:\n      Returns the square root of a number. \n      sqrt is of type: function! \n\nARGUMENTS:\n     number   [number!]  => Angle in radians. \n\nREFINEMENTS:\n" },
  ['square-root'] = { description = "\nUSAGE:\n      square-root value\n\nDESCRIPTION:\n      Returns the square root of a number. \n      square-root is of type: native! \n\nARGUMENTS:\n     value   [number!] \n\nREFINEMENTS:\n" },
  ['stats'] = { description = "\nUSAGE:\n      stats  /show /info\n\nDESCRIPTION:\n      Returns interpreter statistics. \n      stats is of type: native! \n\nARGUMENTS:\n\nREFINEMENTS:\n     /show  => TBD:. \n     /info  => Output formatted results. \n" },
  ['strict-equal?'] = { description = "\nUSAGE:\n      strict-equal? value1 value2\n\nDESCRIPTION:\n      Returns TRUE if two values are equal, and also the same datatype. \n      strict-equal? is of type: native! \n\nARGUMENTS:\n     value1   [any-type!] \n     value2   [any-type!] \n\nREFINEMENTS:\n" },
  ['string?'] = { description = "\nUSAGE:\n      string? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      string? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['subtract'] = { description = "\nUSAGE:\n      subtract value1 value2\n\nDESCRIPTION:\n      Returns the difference between two values. \n      subtract is of type: action! \n\nARGUMENTS:\n     value1   [number! char! pair! tuple! vector! time!] \n     value2   [number! char! pair! tuple! vector! time!] \n\nREFINEMENTS:\n" },
  ['suffix?'] = { description = "\nUSAGE:\n      suffix? path\n\nDESCRIPTION:\n      Returns the suffix (extension) of a filename or url, or NONE if there is no suffix. \n      suffix? is of type: function! \n\nARGUMENTS:\n     path   [file! url! string! email!] \n\nREFINEMENTS:\n" },
  ['swap'] = { description = "\nUSAGE:\n      swap series1 series2\n\nDESCRIPTION:\n      Swaps elements between two series or the same series. \n      swap is of type: action! \n\nARGUMENTS:\n     series1   [series!] \n     series2   [series!] \n\nREFINEMENTS:\n" },
  ['switch'] = { description = "\nUSAGE:\n      switch value cases /default case\n\nDESCRIPTION:\n      Evaluates the first block following the value found in cases. \n      switch is of type: native! \n\nARGUMENTS:\n     value   [any-type!]  => The value to match. \n     cases   [block!] \n\nREFINEMENTS:\n     /default  => Specify a default block, if value is not found in cases. \n         case   [block!]  => Default block to evaluate. \n" },
  ['tag?'] = { description = "\nUSAGE:\n      tag? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      tag? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['tail'] = { description = "\nUSAGE:\n      tail series\n\nDESCRIPTION:\n      Returns a series at the index after its last value. \n      tail is of type: action! \n\nARGUMENTS:\n     series   [series!] \n\nREFINEMENTS:\n" },
  ['tail?'] = { description = "\nUSAGE:\n      tail? series\n\nDESCRIPTION:\n      Returns true if a series is past its last value. \n      tail? is of type: action! \n\nARGUMENTS:\n     series   [series!] \n\nREFINEMENTS:\n" },
  ['take'] = { description = "\nUSAGE:\n      take series /part length /deep /last\n\nDESCRIPTION:\n      Removes and returns one or more elements. \n      take is of type: action! \n\nARGUMENTS:\n     series   [series! none!] \n\nREFINEMENTS:\n     /part  => Specifies a length or end position. \n         length   [number! series!] \n     /deep  => Copy nested values. \n     /last  => Take it from the tail end. \n" },
  ['tan'] = { description = "\nUSAGE:\n      tan angle\n\nDESCRIPTION:\n      Returns the trigonometric tangent. \n      tan is of type: function! \n\nARGUMENTS:\n     angle   [float!]  => Angle in radians. \n\nREFINEMENTS:\n" },
  ['tangent'] = { description = "\nUSAGE:\n      tangent angle /radians\n\nDESCRIPTION:\n      Returns the trigonometric tangent. \n      tangent is of type: native! \n\nARGUMENTS:\n     angle   [number!] \n\nREFINEMENTS:\n     /radians  => Angle is specified in radians. \n" },
  ['third'] = { description = "\nUSAGE:\n      third s\n\nDESCRIPTION:\n      Returns the third value in a series. \n      third is of type: function! \n\nARGUMENTS:\n     s   [series! tuple! time!] \n\nREFINEMENTS:\n" },
  ['throw'] = { description = "\nUSAGE:\n      throw value /name word\n\nDESCRIPTION:\n      Throws control back to a previous catch. \n      throw is of type: native! \n\nARGUMENTS:\n     value   [any-type!]  => Value returned from catch. \n\nREFINEMENTS:\n     /name  => Throws to a named catch. \n         word   [word!] \n" },
  ['time?'] = { description = "\nUSAGE:\n      time? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      time? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['to'] = { description = "\nUSAGE:\n      to type spec\n\nDESCRIPTION:\n      Converts to a specified datatype. \n      to is of type: action! \n\nARGUMENTS:\n     type   [any-type!]  => The datatype or example value. \n     spec   [any-type!]  => The attributes of the new value. \n\nREFINEMENTS:\n" },
  ['to-binary'] = { description = "\nUSAGE:\n      to-binary value\n\nDESCRIPTION:\n      Convert to binary! value. \n      to-binary is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-bitset'] = { description = "\nUSAGE:\n      to-bitset value\n\nDESCRIPTION:\n      Convert to bitset! value. \n      to-bitset is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-block'] = { description = "\nUSAGE:\n      to-block value\n\nDESCRIPTION:\n      Convert to block! value. \n      to-block is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-char'] = { description = "\nUSAGE:\n      to-char value\n\nDESCRIPTION:\n      Convert to char! value. \n      to-char is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-email'] = { description = "\nUSAGE:\n      to-email value\n\nDESCRIPTION:\n      Convert to email! value. \n      to-email is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-file'] = { description = "\nUSAGE:\n      to-file value\n\nDESCRIPTION:\n      Convert to file! value. \n      to-file is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-float'] = { description = "\nUSAGE:\n      to-float value\n\nDESCRIPTION:\n      Convert to float! value. \n      to-float is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-get-path'] = { description = "\nUSAGE:\n      to-get-path value\n\nDESCRIPTION:\n      Convert to get-path! value. \n      to-get-path is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-get-word'] = { description = "\nUSAGE:\n      to-get-word value\n\nDESCRIPTION:\n      Convert to get-word! value. \n      to-get-word is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-hash'] = { description = "\nUSAGE:\n      to-hash value\n\nDESCRIPTION:\n      Convert to hash! value. \n      to-hash is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-hex'] = { description = "\nUSAGE:\n      to-hex value /size length\n\nDESCRIPTION:\n      Converts numeric value to a hex issue! datatype (with leading # and 0's). \n      to-hex is of type: native! \n\nARGUMENTS:\n     value   [integer!] \n\nREFINEMENTS:\n     /size  => Specify number of hex digits in result. \n         length   [integer!] \n" },
  ['to-image'] = { description = "\nUSAGE:\n      to-image value\n\nDESCRIPTION:\n      Convert to image! value. \n      to-image is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-integer'] = { description = "\nUSAGE:\n      to-integer value\n\nDESCRIPTION:\n      Convert to integer! value. \n      to-integer is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-issue'] = { description = "\nUSAGE:\n      to-issue value\n\nDESCRIPTION:\n      Convert to issue! value. \n      to-issue is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-lit-path'] = { description = "\nUSAGE:\n      to-lit-path value\n\nDESCRIPTION:\n      Convert to lit-path! value. \n      to-lit-path is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-lit-word'] = { description = "\nUSAGE:\n      to-lit-word value\n\nDESCRIPTION:\n      Convert to lit-word! value. \n      to-lit-word is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-local-file'] = { description = "\nUSAGE:\n      to-local-file path /full\n\nDESCRIPTION:\n      Converts a Red file path to the local system file path. \n      to-local-file is of type: native! \n\nARGUMENTS:\n     path   [file! string!] \n\nREFINEMENTS:\n     /full  => Prepends current dir for full path (for relative paths only). \n" },
  ['to-logic'] = { description = "\nUSAGE:\n      to-logic value\n\nDESCRIPTION:\n      Convert to logic! value. \n      to-logic is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-map'] = { description = "\nUSAGE:\n      to-map value\n\nDESCRIPTION:\n      Convert to map! value. \n      to-map is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-native'] = { description = "\nUSAGE:\n      to-native value\n\nDESCRIPTION:\n      Convert to native! value. \n      to-native is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-none'] = { description = "\nUSAGE:\n      to-none value\n\nDESCRIPTION:\n      Convert to none! value. \n      to-none is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-pair'] = { description = "\nUSAGE:\n      to-pair value\n\nDESCRIPTION:\n      Convert to pair! value. \n      to-pair is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-paren'] = { description = "\nUSAGE:\n      to-paren value\n\nDESCRIPTION:\n      Convert to paren! value. \n      to-paren is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-path'] = { description = "\nUSAGE:\n      to-path value\n\nDESCRIPTION:\n      Convert to path! value. \n      to-path is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-percent'] = { description = "\nUSAGE:\n      to-percent value\n\nDESCRIPTION:\n      Convert to percent! value. \n      to-percent is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-red-file'] = { description = "\nUSAGE:\n      to-red-file path\nARGUMENTS:\n     path   [file! string!] \n\nREFINEMENTS:\n" },
  ['to-refinement'] = { description = "\nUSAGE:\n      to-refinement value\n\nDESCRIPTION:\n      Convert to refinement! value. \n      to-refinement is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-set-path'] = { description = "\nUSAGE:\n      to-set-path value\n\nDESCRIPTION:\n      Convert to set-path! value. \n      to-set-path is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-set-word'] = { description = "\nUSAGE:\n      to-set-word value\n\nDESCRIPTION:\n      Convert to set-word! value. \n      to-set-word is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-string'] = { description = "\nUSAGE:\n      to-string value\n\nDESCRIPTION:\n      Convert to string! value. \n      to-string is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-tag'] = { description = "\nUSAGE:\n      to-tag value\n\nDESCRIPTION:\n      Convert to tag! value. \n      to-tag is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-time'] = { description = "\nUSAGE:\n      to-time value\n\nDESCRIPTION:\n      Convert to time! value. \n      to-time is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-tuple'] = { description = "\nUSAGE:\n      to-tuple value\n\nDESCRIPTION:\n      Convert to tuple! value. \n      to-tuple is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-typeset'] = { description = "\nUSAGE:\n      to-typeset value\n\nDESCRIPTION:\n      Convert to typeset! value. \n      to-typeset is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-unset'] = { description = "\nUSAGE:\n      to-unset value\n\nDESCRIPTION:\n      Convert to unset! value. \n      to-unset is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-url'] = { description = "\nUSAGE:\n      to-url value\n\nDESCRIPTION:\n      Convert to url! value. \n      to-url is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['to-word'] = { description = "\nUSAGE:\n      to-word value\n\nDESCRIPTION:\n      Convert to word! value. \n      to-word is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['trim'] = { description = "\nUSAGE:\n      trim series /head /tail /auto /lines /all /with str\n\nDESCRIPTION:\n      Removes space from a string or NONE from a block or object. \n      trim is of type: action! \n\nARGUMENTS:\n     series   [series! object! error! map!] \n\nREFINEMENTS:\n     /head  => Removes only from the head. \n     /tail  => Removes only from the tail. \n     /auto  => Auto indents lines relative to first line. \n     /lines  => Removes all line breaks and extra spaces. \n     /all  => Removes all whitespace. \n     /with  => Same as /all, but removes characters in 'str'. \n         str   [char! string! integer!] \n" },
  ['try'] = { description = "\nUSAGE:\n      try block /all\n\nDESCRIPTION:\n      Tries to DO a block and returns its value or an error. \n      try is of type: native! \n\nARGUMENTS:\n     block   [block!] \n\nREFINEMENTS:\n     /all  => Catch also BREAK, CONTINUE, RETURN, EXIT and THROW exceptions. \n" },
  ['tuple?'] = { description = "\nUSAGE:\n      tuple? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      tuple? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['type?'] = { description = "\nUSAGE:\n      type? value /word\n\nDESCRIPTION:\n      Returns the datatype of a value. \n      type? is of type: native! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n     /word  => Return a word value, rather than a datatype value. \n" },
  ['typeset?'] = { description = "\nUSAGE:\n      typeset? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      typeset? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['union'] = { description = "\nUSAGE:\n      union set1 set2 /case /skip size\n\nDESCRIPTION:\n      Returns the union of two data sets. \n      union is of type: native! \n\nARGUMENTS:\n     set1   [block! hash! string! bitset! typeset!] \n     set2   [block! hash! string! bitset! typeset!] \n\nREFINEMENTS:\n     /case  => Use case-sensitive comparison. \n     /skip  => Treat the series as fixed size records. \n         size   [integer!] \n" },
  ['unique'] = { description = "\nUSAGE:\n      unique set /case /skip size\n\nDESCRIPTION:\n      Returns the data set with duplicates removed. \n      unique is of type: native! \n\nARGUMENTS:\n     set   [block! hash! string!] \n\nREFINEMENTS:\n     /case  => Use case-sensitive comparison. \n     /skip  => Treat the series as fixed size records. \n         size   [integer!] \n" },
  ['unless'] = { description = "\nUSAGE:\n      unless cond then-blk\n\nDESCRIPTION:\n      If conditional expression is not TRUE, evaluate block; else return NONE. \n      unless is of type: native! \n\nARGUMENTS:\n     cond   [any-type!] \n     then-blk   [block!] \n\nREFINEMENTS:\n" },
  ['unset'] = { description = "\nUSAGE:\n      unset word\n\nDESCRIPTION:\n      Unsets the value of a word in its current context. \n      unset is of type: native! \n\nARGUMENTS:\n     word   [word! block!]  => Word or block of words. \n\nREFINEMENTS:\n" },
  ['unset?'] = { description = "\nUSAGE:\n      unset? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      unset? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['until'] = { description = "\nUSAGE:\n      until body\n\nDESCRIPTION:\n      Evaluates body until it is TRUE. \n      until is of type: native! \n\nARGUMENTS:\n     body   [block!] \n\nREFINEMENTS:\n" },
  ['uppercase'] = { description = "\nUSAGE:\n      uppercase string /part limit\n\nDESCRIPTION:\n      Converts string of characters to uppercase. \n      uppercase is of type: native! \n\nARGUMENTS:\n     string   [any-string! char!] \n\nREFINEMENTS:\n     /part  => Limits to a given length or position. \n         limit   [number! any-string!] \n" },
  ['url?'] = { description = "\nUSAGE:\n      url? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      url? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['value?'] = { description = "\nUSAGE:\n      value? value\n\nDESCRIPTION:\n      Returns TRUE if the word has a value. \n      value? is of type: native! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['values-of'] = { description = "\nUSAGE:\n      values-of value\n\nDESCRIPTION:\n      Returns the list of values of a value that supports reflection. \n      values-of is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['vector?'] = { description = "\nUSAGE:\n      vector? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      vector? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['wait'] = { description = "\nUSAGE:\n      wait value /all\n\nDESCRIPTION:\n      Waits for a duration in seconds. \n      wait is of type: native! \n\nARGUMENTS:\n     value   [number! block! none!] \n\nREFINEMENTS:\n     /all  => Returns all in a block. \n" },
  ['what'] = { description = "\nUSAGE:\n      what \n\nDESCRIPTION:\n      Lists all functions. \n      what is of type: function! \n\nARGUMENTS:\n\nREFINEMENTS:\n" },
  ['what-dir'] = { description = "\nUSAGE:\n      what-dir \nARGUMENTS:\n\nREFINEMENTS:\n" },
  ['while'] = { description = "\nUSAGE:\n      while cond body\n\nDESCRIPTION:\n      Evaluates body as long as condition block returns TRUE. \n      while is of type: native! \n\nARGUMENTS:\n     cond   [block!]  => Condition block to evaluate on each iteration. \n     body   [block!]  => Block to evaluate on each iteration. \n\nREFINEMENTS:\n" },
  ['word?'] = { description = "\nUSAGE:\n      word? value\n\nDESCRIPTION:\n      Returns true if the value is this type. \n      word? is of type: function! \n\nARGUMENTS:\n     value   [any-type!] \n\nREFINEMENTS:\n" },
  ['words-of'] = { description = "\nUSAGE:\n      words-of value\n\nDESCRIPTION:\n      Returns the list of words of a value that supports reflection. \n      words-of is of type: function! \n\nARGUMENTS:\n     value \n\nREFINEMENTS:\n" },
  ['write'] = { description = "\nUSAGE:\n      write destination data /binary /lines /info /append /part length /seek index /allow access /as encoding\n\nDESCRIPTION:\n      Writes to a file, URL, or other port. \n      write is of type: action! \n\nARGUMENTS:\n     destination   [file! url!] \n     data   [any-type!] \n\nREFINEMENTS:\n     /binary  => Preserves contents exactly. \n     /lines  => Write each value in a block as a separate line. \n     /info \n     /append  => Write data at end of file. \n     /part  => Partial write a given number of units. \n         length   [number!] \n     /seek  => Write at a specific position. \n         index   [number!] \n     /allow  => Specifies protection attributes. \n         access   [block!] \n     /as  => Write with the specified encoding, default is 'UTF-8. \n         encoding   [word!] \n" },
  ['write-stdout'] = { description = "\nUSAGE:\n      write-stdout str\nARGUMENTS:\n     str   [string!] \n\nREFINEMENTS:\n" },
  ['xor'] = { description = "\nUSAGE:\n      value1 xor  value2\n\nDESCRIPTION:\n      Returns the first value exclusive ORed with the second. \n      xor is of type: op! \n\nARGUMENTS:\n     value1   [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n     value2   [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n\nREFINEMENTS:\n" },
  ['xor~'] = { description = "\nUSAGE:\n      xor~ value1 value2\n\nDESCRIPTION:\n      Returns the first value exclusive ORed with the second. \n      xor~ is of type: action! \n\nARGUMENTS:\n     value1   [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n     value2   [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n\nREFINEMENTS:\n" },
  ['zero?'] = { description = "\nUSAGE:\n      zero? value\n\nDESCRIPTION:\n      Returns TRUE if the value is zero. \n      zero? is of type: native! \n\nARGUMENTS:\n     value   [number! pair! time! char! tuple!] \n\nREFINEMENTS:\n" },
  ['_read-input'] = { description = "\nUSAGE:\n      _read-input prompt\nARGUMENTS:\n     prompt   [string!] \n\nREFINEMENTS:\n" },
  ['_set-buffer-history'] = { description = "\nUSAGE:\n      _set-buffer-history line hist\nARGUMENTS:\n     line   [string!] \n     hist   [block!] \n\nREFINEMENTS:\n" },
}