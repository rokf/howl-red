return { 
  ['%'] = { description = "USAGE:\n     value1 % value2\n\nDESCRIPTION: \n     Returns what is left over when one value is divided by another. \n     % is an op! value.\n\nARGUMENTS:\n     value1       [number! char! pair! tuple! vector! time!] \n     value2       [number! char! pair! tuple! vector! time!] \n\nRETURNS:\n     [number! char! pair! tuple! vector! time!]\n" },
  ['*'] = { description = "USAGE:\n     value1 * value2\n\nDESCRIPTION: \n     Returns the product of two values. \n     * is an op! value.\n\nARGUMENTS:\n     value1       [number! char! pair! tuple! vector! time!] \n     value2       [number! char! pair! tuple! vector! time!] \n\nRETURNS:\n     [number! char! pair! tuple! vector! time!]\n" },
  ['**'] = { description = "USAGE:\n     number ** exponent\n\nDESCRIPTION: \n     Returns a number raised to a given power (exponent). \n     ** is an op! value.\n\nARGUMENTS:\n     number       [number!] \"Base value\".\n     exponent     [integer! float!] \"The power (index) to raise the base value by\".\n\nRETURNS:\n     [number!]\n" },
  ['+'] = { description = "USAGE:\n     value1 + value2\n\nDESCRIPTION: \n     Returns the sum of the two values. \n     + is an op! value.\n\nARGUMENTS:\n     value1       [number! char! pair! tuple! vector! time! date!] \n     value2       [number! char! pair! tuple! vector! time! date!] \n\nRETURNS:\n     [number! char! pair! tuple! vector! time! date!]\n" },
  ['-'] = { description = "USAGE:\n     value1 - value2\n\nDESCRIPTION: \n     Returns the difference between two values. \n     - is an op! value.\n\nARGUMENTS:\n     value1       [number! char! pair! tuple! vector! time! date!] \n     value2       [number! char! pair! tuple! vector! time! date!] \n\nRETURNS:\n     [number! char! pair! tuple! vector! time! date!]\n" },
  ['/'] = { description = "USAGE:\n     value1 / value2\n\nDESCRIPTION: \n     Returns the quotient of two values. \n     / is an op! value.\n\nARGUMENTS:\n     value1       [number! char! pair! tuple! vector! time!] \"The dividend (numerator)\".\n     value2       [number! char! pair! tuple! vector! time!] \"The divisor (denominator)\".\n\nRETURNS:\n     [number! char! pair! tuple! vector! time!]\n" },
  ['//'] = { description = "USAGE:\n     a // b\n\nDESCRIPTION: \n     Wrapper for MOD that handles errors like REMAINDER. Negligible values (compared to A and B) are rounded to zero. \n     // is an op! value.\n\nARGUMENTS:\n     a            [number! char! pair! tuple! vector! time!] \n     b            [number! char! pair! tuple! vector! time!] \n\nRETURNS:\n     [number! char! pair! tuple! vector! time!]\n" },
  ['<'] = { description = "USAGE:\n     value1 < value2\n\nDESCRIPTION: \n     Returns TRUE if the first value is less than the second. \n     < is an op! value.\n\nARGUMENTS:\n     value1       [any-type!] \n     value2       [any-type!] \n" },
  ['<<'] = { description = "USAGE:\n     data << bits\n\nDESCRIPTION: \n     << is an op! value.\n\nARGUMENTS:\n     data         [integer!] \n     bits         [integer!] \n" },
  ['<='] = { description = "USAGE:\n     value1 <= value2\n\nDESCRIPTION: \n     Returns TRUE if the first value is less than or equal to the second. \n     <= is an op! value.\n\nARGUMENTS:\n     value1       [any-type!] \n     value2       [any-type!] \n" },
  ['<>'] = { description = "USAGE:\n     value1 <> value2\n\nDESCRIPTION: \n     Returns TRUE if two values are not equal. \n     <> is an op! value.\n\nARGUMENTS:\n     value1       [any-type!] \n     value2       [any-type!] \n" },
  ['='] = { description = "USAGE:\n     value1 = value2\n\nDESCRIPTION: \n     Returns TRUE if two values are equal. \n     = is an op! value.\n\nARGUMENTS:\n     value1       [any-type!] \n     value2       [any-type!] \n" },
  ['=='] = { description = "USAGE:\n     value1 == value2\n\nDESCRIPTION: \n     Returns TRUE if two values are equal, and also the same datatype. \n     == is an op! value.\n\nARGUMENTS:\n     value1       [any-type!] \n     value2       [any-type!] \n" },
  ['=?'] = { description = "USAGE:\n     value1 =? value2\n\nDESCRIPTION: \n     Returns TRUE if two values have the same identity. \n     =? is an op! value.\n\nARGUMENTS:\n     value1       [any-type!] \n     value2       [any-type!] \n" },
  ['>'] = { description = "USAGE:\n     value1 > value2\n\nDESCRIPTION: \n     Returns TRUE if the first value is greater than the second. \n     > is an op! value.\n\nARGUMENTS:\n     value1       [any-type!] \n     value2       [any-type!] \n" },
  ['>='] = { description = "USAGE:\n     value1 >= value2\n\nDESCRIPTION: \n     Returns TRUE if the first value is greater than or equal to the second. \n     >= is an op! value.\n\nARGUMENTS:\n     value1       [any-type!] \n     value2       [any-type!] \n" },
  ['>>'] = { description = "USAGE:\n     data >> bits\n\nDESCRIPTION: \n     >> is an op! value.\n\nARGUMENTS:\n     data         [integer!] \n     bits         [integer!] \n" },
  ['>>>'] = { description = "USAGE:\n     data >>> bits\n\nDESCRIPTION: \n     >>> is an op! value.\n\nARGUMENTS:\n     data         [integer!] \n     bits         [integer!] \n" },
  ['?'] = { description = "USAGE:\n     ? 'word\n\nDESCRIPTION: \n     Displays information about functions, values, objects, and datatypes. \n     ? is a function! value.\n\nARGUMENTS:\n     'word        [any-type!] \n" },
  ['??'] = { description = "USAGE:\n     ?? 'value\n\nDESCRIPTION: \n     Prints a word and the value it refers to (molded). \n     ?? is a function! value.\n\nARGUMENTS:\n     'value       [word! path!] \n" },
  ['a-an'] = { description = "USAGE:\n     A-AN str\n\nDESCRIPTION: \n     Returns the appropriate variant of a or an (simple, vs 100% grammatically correct). \n     A-AN is a function! value.\n\nARGUMENTS:\n     str          [string!] \n\nREFINEMENTS:\n     /pre         => Prepend to str.\n" },
  ['about'] = { description = "USAGE:\n     ABOUT \n\nDESCRIPTION: \n     Print Red version information. \n     ABOUT is a function! value.\n" },
  ['absolute'] = { description = "USAGE:\n     ABSOLUTE value\n\nDESCRIPTION: \n     Returns the non-negative value. \n     ABSOLUTE is an action! value.\n\nARGUMENTS:\n     value        [number! char! pair! time!] \n\nRETURNS:\n     [number! char! pair! time!]\n" },
  ['acos'] = { description = "USAGE:\n     ACOS angle\n\nDESCRIPTION: \n     Returns the trigonometric arccosine. \n     ACOS is a function! value.\n\nARGUMENTS:\n     angle        [float!] \"Angle in radians\".\n" },
  ['action?'] = { description = "USAGE:\n     ACTION? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     ACTION? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['add'] = { description = "USAGE:\n     ADD value1 value2\n\nDESCRIPTION: \n     Returns the sum of the two values. \n     ADD is an action! value.\n\nARGUMENTS:\n     value1       [number! char! pair! tuple! vector! time! date!] \n     value2       [number! char! pair! tuple! vector! time! date!] \n\nRETURNS:\n     [number! char! pair! tuple! vector! time! date!]\n" },
  ['all'] = { description = "USAGE:\n     ALL conds\n\nDESCRIPTION: \n     Evaluates, returning at the first that is not true. \n     ALL is a native! value.\n\nARGUMENTS:\n     conds        [block!] \n" },
  ['all-word?'] = { description = "USAGE:\n     ALL-WORD? value\n\nDESCRIPTION: \n     Returns true if the value is any type of all-word. \n     ALL-WORD? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['also'] = { description = "USAGE:\n     ALSO value1 value2\n\nDESCRIPTION: \n     Returns the first value, but also evaluates the second. \n     ALSO is a function! value.\n\nARGUMENTS:\n     value1       [any-type!] \n     value2       [any-type!] \n" },
  ['alter'] = { description = "USAGE:\n     ALTER series value\n\nDESCRIPTION: \n     If a value is not found in a series, append it; otherwise, remove it. Returns true if added. \n     ALTER is a function! value.\n\nARGUMENTS:\n     series       [series!] \n     value         \n" },
  ['and'] = { description = "USAGE:\n     value1 and value2\n\nDESCRIPTION: \n     Returns the first value ANDed with the second. \n     AND is an op! value.\n\nARGUMENTS:\n     value1       [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n     value2       [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n\nRETURNS:\n     [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!]\n" },
  ['and~'] = { description = "USAGE:\n     AND~ value1 value2\n\nDESCRIPTION: \n     Returns the first value ANDed with the second. \n     AND~ is an action! value.\n\nARGUMENTS:\n     value1       [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n     value2       [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n\nRETURNS:\n     [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!]\n" },
  ['any'] = { description = "USAGE:\n     ANY conds\n\nDESCRIPTION: \n     Evaluates, returning at the first that is true. \n     ANY is a native! value.\n\nARGUMENTS:\n     conds        [block!] \n" },
  ['any-block?'] = { description = "USAGE:\n     ANY-BLOCK? value\n\nDESCRIPTION: \n     Returns true if the value is any type of any-block. \n     ANY-BLOCK? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['any-function?'] = { description = "USAGE:\n     ANY-FUNCTION? value\n\nDESCRIPTION: \n     Returns true if the value is any type of any-function. \n     ANY-FUNCTION? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['any-list?'] = { description = "USAGE:\n     ANY-LIST? value\n\nDESCRIPTION: \n     Returns true if the value is any type of any-list. \n     ANY-LIST? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['any-object?'] = { description = "USAGE:\n     ANY-OBJECT? value\n\nDESCRIPTION: \n     Returns true if the value is any type of any-object. \n     ANY-OBJECT? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['any-path?'] = { description = "USAGE:\n     ANY-PATH? value\n\nDESCRIPTION: \n     Returns true if the value is any type of any-path. \n     ANY-PATH? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['any-string?'] = { description = "USAGE:\n     ANY-STRING? value\n\nDESCRIPTION: \n     Returns true if the value is any type of any-string. \n     ANY-STRING? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['any-word?'] = { description = "USAGE:\n     ANY-WORD? value\n\nDESCRIPTION: \n     Returns true if the value is any type of any-word. \n     ANY-WORD? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['append'] = { description = "USAGE:\n     APPEND series value\n\nDESCRIPTION: \n     Inserts value(s) at series tail; returns series head. \n     APPEND is an action! value.\n\nARGUMENTS:\n     series       [series! bitset!] \n     value        [any-type!] \n\nREFINEMENTS:\n     /part        => Limit the number of values inserted.\n        length       [number! series!] \n     /only        => Insert block types as single values (overrides /part).\n     /dup         => Duplicate the inserted values.\n        count        [number!] \n\nRETURNS:\n     [series! bitset!]\n" },
  ['arccosine'] = { description = "USAGE:\n     ARCCOSINE angle\n\nDESCRIPTION: \n     Returns the trigonometric arccosine (in degrees by default). \n     ARCCOSINE is a native! value.\n\nARGUMENTS:\n     angle        [number!] \n\nREFINEMENTS:\n     /radians     => Angle is specified in radians.\n\nRETURNS:\n     [float!]\n" },
  ['arcsine'] = { description = "USAGE:\n     ARCSINE angle\n\nDESCRIPTION: \n     Returns the trigonometric arcsine (in degrees by default). \n     ARCSINE is a native! value.\n\nARGUMENTS:\n     angle        [number!] \n\nREFINEMENTS:\n     /radians     => Angle is specified in radians.\n\nRETURNS:\n     [float!]\n" },
  ['arctangent'] = { description = "USAGE:\n     ARCTANGENT angle\n\nDESCRIPTION: \n     Returns the trigonometric arctangent (in degrees by default). \n     ARCTANGENT is a native! value.\n\nARGUMENTS:\n     angle        [number!] \n\nREFINEMENTS:\n     /radians     => Angle is specified in radians.\n\nRETURNS:\n     [float!]\n" },
  ['arctangent2'] = { description = "USAGE:\n     ARCTANGENT2 y x\n\nDESCRIPTION: \n     Returns the angle of the point y/x in radians, when measured counterclockwise from a circle's x axis (where 0x0 represents the center of the circle). The return value is between -pi and +pi. \n     ARCTANGENT2 is a native! value.\n\nARGUMENTS:\n     y            [number!] \n     x            [number!] \n\nRETURNS:\n     [float!]\n" },
  ['as'] = { description = "USAGE:\n     AS type spec\n\nDESCRIPTION: \n     Coerce a series into a compatible datatype without copying it. \n     AS is a native! value.\n\nARGUMENTS:\n     type         [datatype! block! paren! any-path! any-string!] \"The datatype or example value\".\n     spec         [block! paren! any-path! any-string!] \"The series to coerce\".\n" },
  ['as-color'] = { description = "USAGE:\n     AS-COLOR r g b\n\nDESCRIPTION: \n     AS-COLOR is a routine! value.\n\nARGUMENTS:\n     r            [integer!] \n     g            [integer!] \n     b            [integer!] \n" },
  ['as-ipv4'] = { description = "USAGE:\n     AS-IPV4 a b c d\n\nDESCRIPTION: \n     AS-IPV4 is a routine! value.\n\nARGUMENTS:\n     a            [integer!] \n     b            [integer!] \n     c            [integer!] \n     d            [integer!] \n" },
  ['as-pair'] = { description = "USAGE:\n     AS-PAIR x y\n\nDESCRIPTION: \n     Combine X and Y values into a pair. \n     AS-PAIR is a native! value.\n\nARGUMENTS:\n     x            [integer! float!] \n     y            [integer! float!] \n" },
  ['as-rgba'] = { description = "USAGE:\n     AS-RGBA a b c d\n\nDESCRIPTION: \n     AS-RGBA is a routine! value.\n\nARGUMENTS:\n     a            [integer!] \n     b            [integer!] \n     c            [integer!] \n     d            [integer!] \n" },
  ['asin'] = { description = "USAGE:\n     ASIN angle\n\nDESCRIPTION: \n     Returns the trigonometric arcsine. \n     ASIN is a function! value.\n\nARGUMENTS:\n     angle        [float!] \"Angle in radians\".\n" },
  ['ask'] = { description = "USAGE:\n     ASK question\n\nDESCRIPTION: \n     ASK is a function! value.\n\nARGUMENTS:\n     question     [string!] \n\nRETURNS:\n     [string!]\n" },
  ['at'] = { description = "USAGE:\n     AT series index\n\nDESCRIPTION: \n     Returns a series at a given index. \n     AT is an action! value.\n\nARGUMENTS:\n     series       [series!] \n     index        [integer! pair!] \n\nRETURNS:\n     [series!]\n" },
  ['atan'] = { description = "USAGE:\n     ATAN angle\n\nDESCRIPTION: \n     Returns the trigonometric arctangent. \n     ATAN is a function! value.\n\nARGUMENTS:\n     angle        [float!] \"Angle in radians\".\n" },
  ['atan2'] = { description = "USAGE:\n     ATAN2 y x\n\nDESCRIPTION: \n     Returns the angle of the point y/x in radians. \n     ATAN2 is a function! value.\n\nARGUMENTS:\n     y            [number!] \n     x            [number!] \n\nRETURNS:\n     [float!]\n" },
  ['attempt'] = { description = "USAGE:\n     ATTEMPT value\n\nDESCRIPTION: \n     Tries to evaluate a block and returns result or NONE on error. \n     ATTEMPT is a function! value.\n\nARGUMENTS:\n     value        [block!] \n\nREFINEMENTS:\n     /safer       => Capture all possible errors and exceptions.\n" },
  ['back'] = { description = "USAGE:\n     BACK series\n\nDESCRIPTION: \n     Returns a series at the previous index. \n     BACK is an action! value.\n\nARGUMENTS:\n     series       [series!] \n\nRETURNS:\n     [series!]\n" },
  ['binary?'] = { description = "USAGE:\n     BINARY? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     BINARY? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['bind'] = { description = "USAGE:\n     BIND word context\n\nDESCRIPTION: \n     BIND is a native! value.\n\nARGUMENTS:\n     word         [block! any-word!] \n     context      [any-word! any-object! function!] \n\nREFINEMENTS:\n     /copy        => \n\nRETURNS:\n     [block! any-word!]\n" },
  ['bitset?'] = { description = "USAGE:\n     BITSET? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     BITSET? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['block?'] = { description = "USAGE:\n     BLOCK? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     BLOCK? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['body-of'] = { description = "USAGE:\n     BODY-OF value\n\nDESCRIPTION: \n     Returns the body of a value that supports reflection. \n     BODY-OF is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['break'] = { description = "USAGE:\n     BREAK \n\nDESCRIPTION: \n     Breaks out of a loop, while, until, repeat, foreach, etc. \n     BREAK is a native! value.\n\nREFINEMENTS:\n     /return      => Forces the loop function to return a value.\n        value        [any-type!] \n" },
  ['browse'] = { description = "USAGE:\n     BROWSE url\n\nDESCRIPTION: \n     Open web browser to a URL or file mananger to a local file. \n     BROWSE is a native! value.\n\nARGUMENTS:\n     url          [url! file!] \n" },
  ['call'] = { description = "USAGE:\n     CALL cmd\n\nDESCRIPTION: \n     Executes a shell command to run another process. \n     CALL is a native! value.\n\nARGUMENTS:\n     cmd          [string! file!] \"A shell command or an executable file\".\n\nREFINEMENTS:\n     /wait        => Runs command and waits for exit.\n     /show        => Force the display of system's shell window (Windows only).\n     /console     => Runs command with I/O redirected to console (CLI console only at present).\n     /shell       => Forces command to be run from shell.\n     /input       => \n        in           [string! file! binary!] \"Redirects in to stdin\".\n     /output      => \n        out          [string! file! binary!] \"Redirects stdout to out\".\n     /error       => \n        err          [string! file! binary!] \"Redirects stderr to err\".\n\nRETURNS:\n     0 if success, -1 if error, or a process ID.\n     [integer!]\n" },
  ['case'] = { description = "USAGE:\n     CASE cases\n\nDESCRIPTION: \n     Evaluates the block following the first true condition. \n     CASE is a native! value.\n\nARGUMENTS:\n     cases        [block!] \"Block of condition-block pairs\".\n\nREFINEMENTS:\n     /all         => Test all conditions, evaluating the block following each true condition.\n" },
  ['catch'] = { description = "USAGE:\n     CATCH block\n\nDESCRIPTION: \n     Catches a throw from a block and returns its value. \n     CATCH is a native! value.\n\nARGUMENTS:\n     block        [block!] \"Block to evaluate\".\n\nREFINEMENTS:\n     /name        => Catches a named throw.\n        word         [word! block!] \"One or more names\".\n" },
  ['cause-error'] = { description = "USAGE:\n     CAUSE-ERROR err-type err-id args\n\nDESCRIPTION: \n     Causes an immediate error throw, with the provided information. \n     CAUSE-ERROR is a function! value.\n\nARGUMENTS:\n     err-type     [word!] \n     err-id       [word!] \n     args         [block!] \n" },
  ['cd'] = { description = "USAGE:\n     CD :dir\n\nDESCRIPTION: \n     Changes the active directory path. \n     CD is a function! value.\n\nARGUMENTS:\n     :dir         [file! word! path!] \"New active directory of relative path to the new one\".\n" },
  ['change'] = { description = "USAGE:\n     CHANGE series value\n\nDESCRIPTION: \n     Changes a value in a series and returns the series after the change. \n     CHANGE is an action! value.\n\nARGUMENTS:\n     series       [series!] \"Series at point to change\".\n     value        [any-type!] \"The new value\".\n\nREFINEMENTS:\n     /part        => Limits the amount to change to a given length or position.\n        range        [number! series!] \n     /only        => Changes a series as a series.\n     /dup         => Duplicates the change a specified number of times.\n        count        [number!] \n" },
  ['change-dir'] = { description = "USAGE:\n     CHANGE-DIR dir\n\nDESCRIPTION: \n     Changes the active directory path. \n     CHANGE-DIR is a function! value.\n\nARGUMENTS:\n     dir          [file! word! path!] \"New active directory of relative path to the new one\".\n" },
  ['char?'] = { description = "USAGE:\n     CHAR? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     CHAR? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['charset'] = { description = "USAGE:\n     CHARSET spec\n\nDESCRIPTION: \n     CHARSET is a function! value.\n\nARGUMENTS:\n     spec         [block! integer! char! string!] \n" },
  ['checksum'] = { description = "USAGE:\n     CHECKSUM data method\n\nDESCRIPTION: \n     Computes a checksum, CRC, hash, or HMAC. \n     CHECKSUM is a native! value.\n\nARGUMENTS:\n     data         [binary! string! file!] \n     method       [word!] \"MD5 SHA1 SHA256 SHA384 SHA512 CRC32 TCP hash\".\n\nREFINEMENTS:\n     /with        => Extra value for HMAC key or hash table size; not compatible with TCP/CRC32 methods.\n        spec         [any-string! binary! integer!] \"String or binary for MD5/SHA* HMAC key, integer for hash table size\".\n\nRETURNS:\n     [integer! binary!]\n" },
  ['class-of'] = { description = "USAGE:\n     CLASS-OF value\n\nDESCRIPTION: \n     Returns the class ID of an object. \n     CLASS-OF is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['clean-path'] = { description = "USAGE:\n     CLEAN-PATH file\n\nDESCRIPTION: \n     Cleans-up '.' and '..' in path; returns the cleaned path. \n     CLEAN-PATH is a function! value.\n\nARGUMENTS:\n     file         [file! url! string!] \n\nREFINEMENTS:\n     /only        => Do not prepend current directory.\n     /dir         => Add a trailing / if missing.\n" },
  ['clear'] = { description = "USAGE:\n     CLEAR series\n\nDESCRIPTION: \n     Removes series values from current index to tail; returns new tail. \n     CLEAR is an action! value.\n\nARGUMENTS:\n     series       [series! bitset! map! none!] \n\nRETURNS:\n     [series! bitset! map! none!]\n" },
  ['clear-reactions'] = { description = "USAGE:\n     CLEAR-REACTIONS \n\nDESCRIPTION: \n     Removes all reactive relations. \n     CLEAR-REACTIONS is a function! value.\n" },
  ['collect'] = { description = "USAGE:\n     COLLECT body\n\nDESCRIPTION: \n     Collect in a new block all the values passed to KEEP function from the body block. \n     COLLECT is a function! value.\n\nARGUMENTS:\n     body         [block!] \"Block to evaluate\".\n\nREFINEMENTS:\n     /into        => Insert into a buffer instead (returns position after insert).\n        collected    [series!] \"The buffer series (modified)\".\n" },
  ['comment'] = { description = "USAGE:\n     COMMENT value\n\nDESCRIPTION: \n     COMMENT is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['common-substr'] = { description = "USAGE:\n     COMMON-SUBSTR blk\n\nDESCRIPTION: \n     COMMON-SUBSTR is a function! value.\n\nARGUMENTS:\n     blk          [block!] \n" },
  ['complement'] = { description = "USAGE:\n     COMPLEMENT value\n\nDESCRIPTION: \n     Returns the opposite (complementing) value of the input value. \n     COMPLEMENT is an action! value.\n\nARGUMENTS:\n     value        [logic! integer! bitset! typeset! binary!] \n\nRETURNS:\n     [logic! integer! bitset! typeset! binary!]\n" },
  ['complement?'] = { description = "USAGE:\n     COMPLEMENT? bits\n\nDESCRIPTION: \n     Returns TRUE if the bitset is complemented. \n     COMPLEMENT? is a native! value.\n\nARGUMENTS:\n     bits         [bitset!] \n" },
  ['compose'] = { description = "USAGE:\n     COMPOSE value\n\nDESCRIPTION: \n     Returns a copy of a block, evaluating only parens. \n     COMPOSE is a native! value.\n\nARGUMENTS:\n     value         \n\nREFINEMENTS:\n     /deep        => Compose nested blocks.\n     /only        => Compose nested blocks as blocks containing their values.\n     /into        => Put results in out block, instead of creating a new block.\n        out          [any-block!] \"Target block for results, when /into is used\".\n" },
  ['construct'] = { description = "USAGE:\n     CONSTRUCT block\n\nDESCRIPTION: \n     CONSTRUCT is a native! value.\n\nARGUMENTS:\n     block        [block!] \n\nREFINEMENTS:\n     /with        => \n        object       [object!] \n     /only        => \n" },
  ['context'] = { description = "USAGE:\n     CONTEXT spec\n\nDESCRIPTION: \n     CONTEXT is a function! value.\n\nARGUMENTS:\n     spec         [block!] \n" },
  ['context?'] = { description = "USAGE:\n     CONTEXT? word\n\nDESCRIPTION: \n     Returns the context in which a word is bound. \n     CONTEXT? is a native! value.\n\nARGUMENTS:\n     word         [any-word!] \"Word to check\".\n\nRETURNS:\n     [object! function! none!]\n" },
  ['continue'] = { description = "USAGE:\n     CONTINUE \n\nDESCRIPTION: \n     Throws control back to top of loop. \n     CONTINUE is a native! value.\n" },
  ['copy'] = { description = "USAGE:\n     COPY value\n\nDESCRIPTION: \n     Returns a copy of a non-scalar value. \n     COPY is an action! value.\n\nARGUMENTS:\n     value        [series! any-object! bitset! map!] \n\nREFINEMENTS:\n     /part        => Limit the length of the result.\n        length       [number! series! pair!] \n     /deep        => Copy nested values.\n     /types       => Copy only specific types of non-scalar values.\n        kind         [datatype!] \n\nRETURNS:\n     [series! any-object! bitset! map!]\n" },
  ['cos'] = { description = "USAGE:\n     COS angle\n\nDESCRIPTION: \n     Returns the trigonometric cosine. \n     COS is a function! value.\n\nARGUMENTS:\n     angle        [float!] \"Angle in radians\".\n" },
  ['cosine'] = { description = "USAGE:\n     COSINE angle\n\nDESCRIPTION: \n     Returns the trigonometric cosine. \n     COSINE is a native! value.\n\nARGUMENTS:\n     angle        [number!] \n\nREFINEMENTS:\n     /radians     => Angle is specified in radians.\n\nRETURNS:\n     [float!]\n" },
  ['create-dir'] = { description = "USAGE:\n     CREATE-DIR path\n\nDESCRIPTION: \n     CREATE-DIR is a routine! value.\n\nARGUMENTS:\n     path         [file!] \n" },
  ['datatype?'] = { description = "USAGE:\n     DATATYPE? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     DATATYPE? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['date?'] = { description = "USAGE:\n     DATE? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     DATE? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['debase'] = { description = "USAGE:\n     DEBASE value\n\nDESCRIPTION: \n     Decodes binary-coded string (BASE-64 default) to binary value. \n     DEBASE is a native! value.\n\nARGUMENTS:\n     value        [string!] \"The string to decode\".\n\nREFINEMENTS:\n     /base        => Binary base to use.\n        base-value   [integer!] \"The base to convert from: 64, 16, or 2\".\n" },
  ['dehex'] = { description = "USAGE:\n     DEHEX value\n\nDESCRIPTION: \n     Converts URL-style hex encoded (%xx) strings. \n     DEHEX is a native! value.\n\nARGUMENTS:\n     value        [string! file!] \n" },
  ['delete'] = { description = "USAGE:\n     DELETE file\n\nDESCRIPTION: \n     Deletes the specified file or empty folder. \n     DELETE is an action! value.\n\nARGUMENTS:\n     file         [file!] \n" },
  ['difference'] = { description = "USAGE:\n     DIFFERENCE set1 set2\n\nDESCRIPTION: \n     Returns the special difference of two data sets. \n     DIFFERENCE is a native! value.\n\nARGUMENTS:\n     set1         [block! hash! string! bitset! typeset! date!] \n     set2         [block! hash! string! bitset! typeset! date!] \n\nREFINEMENTS:\n     /case        => Use case-sensitive comparison.\n     /skip        => Treat the series as fixed size records.\n        size         [integer!] \n\nRETURNS:\n     [block! hash! string! bitset! typeset!]\n" },
  ['dir'] = { description = "USAGE:\n     DIR 'dir\n\nDESCRIPTION: \n     DIR is a function! value.\n\nARGUMENTS:\n     'dir         [any-type!] \n" },
  ['dir?'] = { description = "USAGE:\n     DIR? file\n\nDESCRIPTION: \n     DIR? is a function! value.\n\nARGUMENTS:\n     file         [file! url!] \n" },
  ['dirize'] = { description = "USAGE:\n     DIRIZE path\n\nDESCRIPTION: \n     Returns a copy of the path turned into a directory. \n     DIRIZE is a function! value.\n\nARGUMENTS:\n     path         [file! string! url!] \n" },
  ['divide'] = { description = "USAGE:\n     DIVIDE value1 value2\n\nDESCRIPTION: \n     Returns the quotient of two values. \n     DIVIDE is an action! value.\n\nARGUMENTS:\n     value1       [number! char! pair! tuple! vector! time!] \"The dividend (numerator)\".\n     value2       [number! char! pair! tuple! vector! time!] \"The divisor (denominator)\".\n\nRETURNS:\n     [number! char! pair! tuple! vector! time!]\n" },
  ['do'] = { description = "USAGE:\n     DO value\n\nDESCRIPTION: \n     Evaluates a value, returning the last evaluation result. \n     DO is a native! value.\n\nARGUMENTS:\n     value        [any-type!] \n\nREFINEMENTS:\n     /expand      => Expand directives before evaluation.\n     /args        => If value is a script, this will set its system/script/args.\n        arg           \"Args passed to a script (normally a string)\".\n     /next        => Do next expression only, return it, update block word.\n        position     [word!] \"Word updated with new block position\".\n" },
  ['do-file'] = { description = "USAGE:\n     DO-FILE file\n\nDESCRIPTION: \n     DO-FILE is a function! value.\n\nARGUMENTS:\n     file         [file! url!] \n" },
  ['do-thru'] = { description = "USAGE:\n     DO-THRU url\n\nDESCRIPTION: \n     Evaluates a remote Red script through local disk cache. \n     DO-THRU is a function! value.\n\nARGUMENTS:\n     url          [url!] \"Remote file address\".\n\nREFINEMENTS:\n     /update      => Force a cache update.\n" },
  ['does'] = { description = "USAGE:\n     DOES body\n\nDESCRIPTION: \n     Defines a function with no arguments or local variables. \n     DOES is a native! value.\n\nARGUMENTS:\n     body         [block!] \n" },
  ['dump-reactions'] = { description = "USAGE:\n     DUMP-REACTIONS \n\nDESCRIPTION: \n     Output all the current reactive relations for debugging purpose. \n     DUMP-REACTIONS is a function! value.\n" },
  ['either'] = { description = "USAGE:\n     EITHER cond true-blk false-blk\n\nDESCRIPTION: \n     If conditional expression is true, eval true-block; else eval false-blk. \n     EITHER is a native! value.\n\nARGUMENTS:\n     cond         [any-type!] \n     true-blk     [block!] \n     false-blk    [block!] \n" },
  ['ellipsize-at'] = { description = "USAGE:\n     ELLIPSIZE-AT str len\n\nDESCRIPTION: \n     Truncate and add ellipsis if str is longer than len. \n     ELLIPSIZE-AT is a function! value.\n\nARGUMENTS:\n     str          [string!] \"(modified)\".\n     len          [integer!] \"Max length\".\n" },
  ['email?'] = { description = "USAGE:\n     EMAIL? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     EMAIL? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['empty?'] = { description = "USAGE:\n     EMPTY? series\n\nDESCRIPTION: \n     Returns true if a series is at its tail. \n     EMPTY? is a function! value.\n\nARGUMENTS:\n     series       [series! none!] \n\nRETURNS:\n     [logic!]\n" },
  ['enbase'] = { description = "USAGE:\n     ENBASE value\n\nDESCRIPTION: \n     Encodes a string into a binary-coded string (BASE-64 default). \n     ENBASE is a native! value.\n\nARGUMENTS:\n     value        [binary! string!] \"If string, will be UTF8 encoded\".\n\nREFINEMENTS:\n     /base        => Binary base to use.\n        base-value   [integer!] \"The base to convert from: 64, 16, or 2\".\n" },
  ['equal?'] = { description = "USAGE:\n     EQUAL? value1 value2\n\nDESCRIPTION: \n     Returns TRUE if two values are equal. \n     EQUAL? is a native! value.\n\nARGUMENTS:\n     value1       [any-type!] \n     value2       [any-type!] \n" },
  ['error?'] = { description = "USAGE:\n     ERROR? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     ERROR? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['eval-set-path'] = { description = "USAGE:\n     EVAL-SET-PATH value1\n\nDESCRIPTION: \n     EVAL-SET-PATH is a function! value.\n\nARGUMENTS:\n     value1        \n" },
  ['even?'] = { description = "USAGE:\n     EVEN? number\n\nDESCRIPTION: \n     Returns true if the number is evenly divisible by 2. \n     EVEN? is an action! value.\n\nARGUMENTS:\n     number       [number! char! time!] \n\nRETURNS:\n     [number! char! time!]\n" },
  ['exclude'] = { description = "USAGE:\n     EXCLUDE set1 set2\n\nDESCRIPTION: \n     Returns the first data set less the second data set. \n     EXCLUDE is a native! value.\n\nARGUMENTS:\n     set1         [block! hash! string! bitset! typeset!] \n     set2         [block! hash! string! bitset! typeset!] \n\nREFINEMENTS:\n     /case        => Use case-sensitive comparison.\n     /skip        => Treat the series as fixed size records.\n        size         [integer!] \n\nRETURNS:\n     [block! hash! string! bitset! typeset!]\n" },
  ['exists-thru?'] = { description = "USAGE:\n     EXISTS-THRU? url\n\nDESCRIPTION: \n     Returns true if the remote file is present in the local disk cache. \n     EXISTS-THRU? is a function! value.\n\nARGUMENTS:\n     url          [url! file!] \"Remote file address\".\n" },
  ['exists?'] = { description = "USAGE:\n     EXISTS? path\n\nDESCRIPTION: \n     EXISTS? is a routine! value.\n\nARGUMENTS:\n     path         [file!] \n\nRETURNS:\n     [logic!]\n" },
  ['exit'] = { description = "USAGE:\n     EXIT \n\nDESCRIPTION: \n     Exits a function, returning no value. \n     EXIT is a native! value.\n" },
  ['exp'] = { description = "USAGE:\n     EXP value\n\nDESCRIPTION: \n     Raises E (the base of natural logarithm) to the power specified. \n     EXP is a native! value.\n\nARGUMENTS:\n     value        [number!] \n\nRETURNS:\n     [float!]\n" },
  ['expand'] = { description = "USAGE:\n     EXPAND blk\n\nDESCRIPTION: \n     Preprocess the argument block and display the output (console only). \n     EXPAND is a function! value.\n\nARGUMENTS:\n     blk          [block!] \"Block to expand\".\n" },
  ['expand-directives'] = { description = "USAGE:\n     EXPAND-DIRECTIVES code\n\nDESCRIPTION: \n     Invokes the preprocessor on argument list, modifying and returning it. \n     EXPAND-DIRECTIVES is a function! value.\n\nARGUMENTS:\n     code         [block! paren!] \"List of Red values to preprocess\".\n\nREFINEMENTS:\n     /clean       => Clear all previously created macros and words.\n" },
  ['extend'] = { description = "USAGE:\n     EXTEND obj spec\n\nDESCRIPTION: \n     Extend an object or map value with list of key and value pairs. \n     EXTEND is a native! value.\n\nARGUMENTS:\n     obj          [object! map!] \n     spec         [block! hash! map!] \n\nREFINEMENTS:\n     /case        => Use case-sensitive comparison.\n" },
  ['extract'] = { description = "USAGE:\n     EXTRACT series width\n\nDESCRIPTION: \n     Extracts a value from a series at regular intervals. \n     EXTRACT is a function! value.\n\nARGUMENTS:\n     series       [series!] \n     width        [integer!] \"Size of each entry (the skip)\".\n\nREFINEMENTS:\n     /index       => Extract from an offset position.\n        pos          [integer!] \"The position\".\n     /into        => Provide an output series instead of creating a new one.\n        output       [series!] \"Output series\".\n" },
  ['extract-boot-args'] = { description = "USAGE:\n     EXTRACT-BOOT-ARGS \n\nDESCRIPTION: \n     Process command-line arguments and store values in system/options (internal usage). \n     EXTRACT-BOOT-ARGS is a function! value.\n" },
  ['fetch-help'] = { description = "USAGE:\n     FETCH-HELP 'word\n\nDESCRIPTION: \n     Returns information about functions, values, objects, and datatypes. \n     FETCH-HELP is a function! value.\n\nARGUMENTS:\n     'word        [any-type!] \n" },
  ['fifth'] = { description = "USAGE:\n     FIFTH s\n\nDESCRIPTION: \n     Returns the fifth value in a series. \n     FIFTH is a function! value.\n\nARGUMENTS:\n     s            [series! tuple!] \n" },
  ['file?'] = { description = "USAGE:\n     FILE? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     FILE? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['find'] = { description = "USAGE:\n     FIND series value\n\nDESCRIPTION: \n     Returns the series where a value is found, or NONE. \n     FIND is an action! value.\n\nARGUMENTS:\n     series       [series! bitset! typeset! any-object! map! none!] \n     value        [any-type!] \n\nREFINEMENTS:\n     /part        => Limit the length of the search.\n        length       [number! series!] \n     /only        => Treat a series search value as a single value.\n     /case        => Perform a case-sensitive search.\n     /same        => Use \"same?\" as comparator.\n     /any         => TBD: Use * and ? wildcards in string searches.\n     /with        => TBD: Use custom wildcards in place of * and ?.\n        wild         [string!] \n     /skip        => Treat the series as fixed size records.\n        size         [integer!] \n     /last        => Find the last occurrence of value, from the tail.\n     /reverse     => Find the last occurrence of value, from the current index.\n     /tail        => Return the tail of the match found, rather than the head.\n     /match       => Match at current index only and return tail of match.\n" },
  ['first'] = { description = "USAGE:\n     FIRST s\n\nDESCRIPTION: \n     Returns the first value in a series. \n     FIRST is a function! value.\n\nARGUMENTS:\n     s            [series! tuple! pair! time!] \n" },
  ['flip-exe-flag'] = { description = "USAGE:\n     FLIP-EXE-FLAG path\n\nDESCRIPTION: \n     Flip the sub-system for the red.exe between console and GUI modes (Windows only). \n     FLIP-EXE-FLAG is a function! value.\n\nARGUMENTS:\n     path         [file!] \"Path to the red.exe\".\n" },
  ['float?'] = { description = "USAGE:\n     FLOAT? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     FLOAT? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['forall'] = { description = "USAGE:\n     FORALL 'word body\n\nDESCRIPTION: \n     Evaluates body for all values in a series. \n     FORALL is a native! value.\n\nARGUMENTS:\n     'word        [word!] \"Word referring to series to iterate over\".\n     body         [block!] \n" },
  ['foreach'] = { description = "USAGE:\n     FOREACH 'word series body\n\nDESCRIPTION: \n     Evaluates body for each value in a series. \n     FOREACH is a native! value.\n\nARGUMENTS:\n     'word        [word! block!] \"Word, or words, to set on each iteration\".\n     series       [series!] \n     body         [block!] \n" },
  ['forever'] = { description = "USAGE:\n     FOREVER body\n\nDESCRIPTION: \n     Evaluates body repeatedly forever. \n     FOREVER is a native! value.\n\nARGUMENTS:\n     body         [block!] \n" },
  ['form'] = { description = "USAGE:\n     FORM value\n\nDESCRIPTION: \n     Returns a user-friendly string representation of a value. \n     FORM is an action! value.\n\nARGUMENTS:\n     value        [any-type!] \n\nREFINEMENTS:\n     /part        => Limit the length of the result.\n        limit        [integer!] \n\nRETURNS:\n     [string!]\n" },
  ['fourth'] = { description = "USAGE:\n     FOURTH s\n\nDESCRIPTION: \n     Returns the fourth value in a series. \n     FOURTH is a function! value.\n\nARGUMENTS:\n     s            [series! tuple!] \n" },
  ['func'] = { description = "USAGE:\n     FUNC spec body\n\nDESCRIPTION: \n     Defines a function with a given spec and body. \n     FUNC is a native! value.\n\nARGUMENTS:\n     spec         [block!] \n     body         [block!] \n" },
  ['function'] = { description = "USAGE:\n     FUNCTION spec body\n\nDESCRIPTION: \n     Defines a function, making all set-words found in body, local. \n     FUNCTION is a native! value.\n\nARGUMENTS:\n     spec         [block!] \n     body         [block!] \n\nREFINEMENTS:\n     /extern      => Exclude words that follow this refinement.\n" },
  ['function?'] = { description = "USAGE:\n     FUNCTION? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     FUNCTION? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['get'] = { description = "USAGE:\n     GET word\n\nDESCRIPTION: \n     Returns the value a word refers to. \n     GET is a native! value.\n\nARGUMENTS:\n     word         [word! path!] \n\nREFINEMENTS:\n     /any         => If word has no value, return UNSET rather than causing an error.\n     /case        => Use case-sensitive comparison (path only).\n\nRETURNS:\n     [any-type!]\n" },
  ['get-api-data'] = { description = "USAGE:\n     GET-API-DATA \n\nDESCRIPTION: \n     GET-API-DATA is a function! value.\n" },
  ['get-current-dir'] = { description = "USAGE:\n     GET-CURRENT-DIR \n\nDESCRIPTION: \n     GET-CURRENT-DIR is a routine! value.\n" },
  ['get-env'] = { description = "USAGE:\n     GET-ENV var\n\nDESCRIPTION: \n     Returns the value of an OS environment variable (for current process). \n     GET-ENV is a native! value.\n\nARGUMENTS:\n     var          [any-string! any-word!] \"Variable to get\".\n\nRETURNS:\n     [string! none!]\n" },
  ['get-path?'] = { description = "USAGE:\n     GET-PATH? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     GET-PATH? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['get-word?'] = { description = "USAGE:\n     GET-WORD? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     GET-WORD? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['greater-or-equal?'] = { description = "USAGE:\n     GREATER-OR-EQUAL? value1 value2\n\nDESCRIPTION: \n     Returns TRUE if the first value is greater than or equal to the second. \n     GREATER-OR-EQUAL? is a native! value.\n\nARGUMENTS:\n     value1       [any-type!] \n     value2       [any-type!] \n" },
  ['greater?'] = { description = "USAGE:\n     GREATER? value1 value2\n\nDESCRIPTION: \n     Returns TRUE if the first value is greater than the second. \n     GREATER? is a native! value.\n\nARGUMENTS:\n     value1       [any-type!] \n     value2       [any-type!] \n" },
  ['halt'] = { description = "USAGE:\n     HALT \n\nDESCRIPTION: \n     HALT is a function! value.\n" },
  ['handle?'] = { description = "USAGE:\n     HANDLE? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     HANDLE? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['has'] = { description = "USAGE:\n     HAS vars body\n\nDESCRIPTION: \n     Defines a function with local variables, but no arguments. \n     HAS is a native! value.\n\nARGUMENTS:\n     vars         [block!] \n     body         [block!] \n" },
  ['hash?'] = { description = "USAGE:\n     HASH? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     HASH? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['head'] = { description = "USAGE:\n     HEAD series\n\nDESCRIPTION: \n     Returns a series at its first index. \n     HEAD is an action! value.\n\nARGUMENTS:\n     series       [series!] \n\nRETURNS:\n     [series!]\n" },
  ['head?'] = { description = "USAGE:\n     HEAD? series\n\nDESCRIPTION: \n     Returns true if a series is at its first index. \n     HEAD? is an action! value.\n\nARGUMENTS:\n     series       [series!] \n\nRETURNS:\n     [logic!]\n" },
  ['help'] = { description = "USAGE:\n     HELP 'word\n\nDESCRIPTION: \n     Displays information about functions, values, objects, and datatypes. \n     HELP is a function! value.\n\nARGUMENTS:\n     'word        [any-type!] \n" },
  ['help-string'] = { description = "USAGE:\n     HELP-STRING 'word\n\nDESCRIPTION: \n     Returns information about functions, values, objects, and datatypes. \n     HELP-STRING is a function! value.\n\nARGUMENTS:\n     'word        [any-type!] \n" },
  ['if'] = { description = "USAGE:\n     IF cond then-blk\n\nDESCRIPTION: \n     If conditional expression is TRUE, evaluate block; else return NONE. \n     IF is a native! value.\n\nARGUMENTS:\n     cond         [any-type!] \n     then-blk     [block!] \n" },
  ['image?'] = { description = "USAGE:\n     IMAGE? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     IMAGE? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['immediate?'] = { description = "USAGE:\n     IMMEDIATE? value\n\nDESCRIPTION: \n     Returns true if the value is any type of immediate. \n     IMMEDIATE? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['in'] = { description = "USAGE:\n     IN object word\n\nDESCRIPTION: \n     Returns the given word bound to the object's context. \n     IN is a native! value.\n\nARGUMENTS:\n     object       [any-object!] \n     word         [any-word!] \n" },
  ['index?'] = { description = "USAGE:\n     INDEX? series\n\nDESCRIPTION: \n     Returns the current index of series relative to the head, or of word in a context. \n     INDEX? is an action! value.\n\nARGUMENTS:\n     series       [series! word!] \n\nRETURNS:\n     [integer!]\n" },
  ['input'] = { description = "USAGE:\n     INPUT \n\nDESCRIPTION: \n     INPUT is a function! value.\n" },
  ['insert'] = { description = "USAGE:\n     INSERT series value\n\nDESCRIPTION: \n     Inserts value(s) at series index; returns series past the insertion. \n     INSERT is an action! value.\n\nARGUMENTS:\n     series       [series! bitset!] \n     value        [any-type!] \n\nREFINEMENTS:\n     /part        => Limit the number of values inserted.\n        length       [number! series!] \n     /only        => Insert block types as single values (overrides /part).\n     /dup         => Duplicate the inserted values.\n        count        [number!] \n\nRETURNS:\n     [series! bitset!]\n" },
  ['integer?'] = { description = "USAGE:\n     INTEGER? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     INTEGER? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['intersect'] = { description = "USAGE:\n     INTERSECT set1 set2\n\nDESCRIPTION: \n     Returns the intersection of two data sets. \n     INTERSECT is a native! value.\n\nARGUMENTS:\n     set1         [block! hash! string! bitset! typeset!] \n     set2         [block! hash! string! bitset! typeset!] \n\nREFINEMENTS:\n     /case        => Use case-sensitive comparison.\n     /skip        => Treat the series as fixed size records.\n        size         [integer!] \n\nRETURNS:\n     [block! hash! string! bitset! typeset!]\n" },
  ['is'] = { description = "USAGE:\n     field is reaction\n\nDESCRIPTION: \n     Defines a reactive relation whose result is assigned to a word. \n     IS is an op! value.\n\nARGUMENTS:\n     'field       [set-word!] \"Set-word which will get set to the result of the reaction\".\n     reaction     [block!] \"Reactive relation\".\n" },
  ['issue?'] = { description = "USAGE:\n     ISSUE? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     ISSUE? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['keys-of'] = { description = "USAGE:\n     KEYS-OF value\n\nDESCRIPTION: \n     Returns the list of words of a value that supports reflection. \n     KEYS-OF is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['last'] = { description = "USAGE:\n     LAST s\n\nDESCRIPTION: \n     Returns the last value in a series. \n     LAST is a function! value.\n\nARGUMENTS:\n     s            [series!] \n" },
  ['last-lf?'] = { description = "USAGE:\n     LAST-LF? \n\nDESCRIPTION: \n     LAST-LF? is a routine! value.\n" },
  ['length?'] = { description = "USAGE:\n     LENGTH? series\n\nDESCRIPTION: \n     Returns the number of values in the series, from the current index to the tail. \n     LENGTH? is an action! value.\n\nARGUMENTS:\n     series       [series! bitset! map! tuple! none!] \n\nRETURNS:\n     [integer! none!]\n" },
  ['lesser-or-equal?'] = { description = "USAGE:\n     LESSER-OR-EQUAL? value1 value2\n\nDESCRIPTION: \n     Returns TRUE if the first value is less than or equal to the second. \n     LESSER-OR-EQUAL? is a native! value.\n\nARGUMENTS:\n     value1       [any-type!] \n     value2       [any-type!] \n" },
  ['lesser?'] = { description = "USAGE:\n     LESSER? value1 value2\n\nDESCRIPTION: \n     Returns TRUE if the first value is less than the second. \n     LESSER? is a native! value.\n\nARGUMENTS:\n     value1       [any-type!] \n     value2       [any-type!] \n" },
  ['list-dir'] = { description = "USAGE:\n     LIST-DIR dir\n\nDESCRIPTION: \n     Displays a list of files and directories from given folder or current one. \n     LIST-DIR is a function! value.\n\nARGUMENTS:\n     dir          [any-type!] \"Folder to list\".\n\nREFINEMENTS:\n     /col         => Forces the display in a given number of columns.\n        n            [integer!] \"Number of columns\".\n" },
  ['list-env'] = { description = "USAGE:\n     LIST-ENV \n\nDESCRIPTION: \n     Returns a map of OS environment variables (for current process). \n     LIST-ENV is a native! value.\n\nRETURNS:\n     [map!]\n" },
  ['lit-path?'] = { description = "USAGE:\n     LIT-PATH? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     LIT-PATH? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['lit-word?'] = { description = "USAGE:\n     LIT-WORD? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     LIT-WORD? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['ll'] = { description = "USAGE:\n     LL 'dir\n\nDESCRIPTION: \n     LL is a function! value.\n\nARGUMENTS:\n     'dir         [any-type!] \n" },
  ['load'] = { description = "USAGE:\n     LOAD source\n\nDESCRIPTION: \n     Returns a value or block of values by reading and evaluating a source. \n     LOAD is a function! value.\n\nARGUMENTS:\n     source       [file! url! string! binary!] \n\nREFINEMENTS:\n     /header      => TBD.\n     /all         => Load all values, returns a block. TBD: Don't evaluate Red header.\n     /trap        => Load all values, returns [[values] position error].\n     /next        => Load the next value only, updates source series word.\n        position     [word!] \"Word updated with new series position\".\n     /part        => \n        length       [integer! string!] \n     /into        => Put results in out block, instead of creating a new block.\n        out          [block!] \"Target block for results\".\n     /as          => Specify the type of data; use NONE to load as code.\n        type         [word! none!] \"E.g. json, html, jpeg, png, etc\".\n" },
  ['load-thru'] = { description = "USAGE:\n     LOAD-THRU url\n\nDESCRIPTION: \n     Loads a remote file through local disk cache. \n     LOAD-THRU is a function! value.\n\nARGUMENTS:\n     url          [url!] \"Remote file address\".\n\nREFINEMENTS:\n     /update      => Force a cache update.\n     /as          => Specify the type of data; use NONE to load as code.\n        type         [word! none!] \"E.g. json, html, jpeg, png, etc\".\n" },
  ['log-10'] = { description = "USAGE:\n     LOG-10 value\n\nDESCRIPTION: \n     Returns the base-10 logarithm. \n     LOG-10 is a native! value.\n\nARGUMENTS:\n     value        [number!] \n\nRETURNS:\n     [float!]\n" },
  ['log-2'] = { description = "USAGE:\n     LOG-2 value\n\nDESCRIPTION: \n     Return the base-2 logarithm. \n     LOG-2 is a native! value.\n\nARGUMENTS:\n     value        [number!] \n\nRETURNS:\n     [float!]\n" },
  ['log-e'] = { description = "USAGE:\n     LOG-E value\n\nDESCRIPTION: \n     Returns the natural (base-E) logarithm of the given value. \n     LOG-E is a native! value.\n\nARGUMENTS:\n     value        [number!] \n\nRETURNS:\n     [float!]\n" },
  ['logic?'] = { description = "USAGE:\n     LOGIC? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     LOGIC? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['loop'] = { description = "USAGE:\n     LOOP count body\n\nDESCRIPTION: \n     Evaluates body a number of times. \n     LOOP is a native! value.\n\nARGUMENTS:\n     count        [integer!] \n     body         [block!] \n" },
  ['lowercase'] = { description = "USAGE:\n     LOWERCASE string\n\nDESCRIPTION: \n     Converts string of characters to lowercase. \n     LOWERCASE is a native! value.\n\nARGUMENTS:\n     string       [any-string! char!] \n\nREFINEMENTS:\n     /part        => Limits to a given length or position.\n        limit        [number! any-string!] \n\nRETURNS:\n     [any-string! char!]\n" },
  ['ls'] = { description = "USAGE:\n     LS 'dir\n\nDESCRIPTION: \n     LS is a function! value.\n\nARGUMENTS:\n     'dir         [any-type!] \n" },
  ['make'] = { description = "USAGE:\n     MAKE type spec\n\nDESCRIPTION: \n     Returns a new value made from a spec for that value's type. \n     MAKE is an action! value.\n\nARGUMENTS:\n     type         [any-type!] \"The datatype, an example or prototype value\".\n     spec         [any-type!] \"The specification of the new value\".\n\nRETURNS:\n     Returns the specified datatype.\n     [any-type!]\n" },
  ['make-dir'] = { description = "USAGE:\n     MAKE-DIR path\n\nDESCRIPTION: \n     Creates the specified directory. No error if already exists. \n     MAKE-DIR is a function! value.\n\nARGUMENTS:\n     path         [file!] \n\nREFINEMENTS:\n     /deep        => Create subdirectories too.\n" },
  ['map?'] = { description = "USAGE:\n     MAP? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     MAP? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['math'] = { description = "USAGE:\n     MATH body\n\nDESCRIPTION: \n     Evaluates a block using math precedence rules, returning the last result. \n     MATH is a function! value.\n\nARGUMENTS:\n     body         [block!] \"Block to evaluate\".\n\nREFINEMENTS:\n     /safe        => Returns NONE on error.\n" },
  ['max'] = { description = "USAGE:\n     MAX value1 value2\n\nDESCRIPTION: \n     Returns the greater of the two values. \n     MAX is a native! value.\n\nARGUMENTS:\n     value1       [scalar! series!] \n     value2       [scalar! series!] \n" },
  ['min'] = { description = "USAGE:\n     MIN value1 value2\n\nDESCRIPTION: \n     Returns the lesser of the two values. \n     MIN is a native! value.\n\nARGUMENTS:\n     value1       [scalar! series!] \n     value2       [scalar! series!] \n" },
  ['mod'] = { description = "USAGE:\n     MOD a b\n\nDESCRIPTION: \n     Compute a nonnegative remainder of A divided by B. \n     MOD is a function! value.\n\nARGUMENTS:\n     a            [number! char! pair! tuple! vector! time!] \n     b            [number! char! pair! tuple! vector! time!] \"Must be nonzero\".\n\nRETURNS:\n     [number! char! pair! tuple! vector! time!]\n" },
  ['modify'] = { description = "USAGE:\n     MODIFY target field value\n\nDESCRIPTION: \n     Change mode for target aggregate value. \n     MODIFY is an action! value.\n\nARGUMENTS:\n     target       [object! series!] \n     field        [word!] \n     value        [any-type!] \n\nREFINEMENTS:\n     /case        => Perform a case-sensitive lookup.\n\nRETURNS:\n     [map! file!]\n" },
  ['modulo'] = { description = "USAGE:\n     MODULO a b\n\nDESCRIPTION: \n     Wrapper for MOD that handles errors like REMAINDER. Negligible values (compared to A and B) are rounded to zero. \n     MODULO is a function! value.\n\nARGUMENTS:\n     a            [number! char! pair! tuple! vector! time!] \n     b            [number! char! pair! tuple! vector! time!] \n\nRETURNS:\n     [number! char! pair! tuple! vector! time!]\n" },
  ['mold'] = { description = "USAGE:\n     MOLD value\n\nDESCRIPTION: \n     Returns a source format string representation of a value. \n     MOLD is an action! value.\n\nARGUMENTS:\n     value        [any-type!] \n\nREFINEMENTS:\n     /only        => Exclude outer brackets if value is a block.\n     /all         => TBD: Return value in loadable format.\n     /flat        => TBD: Exclude all indentation.\n     /part        => Limit the length of the result.\n        limit        [integer!] \n\nRETURNS:\n     [string!]\n" },
  ['move'] = { description = "USAGE:\n     MOVE origin target\n\nDESCRIPTION: \n     Moves one or more elements from one series to another position or series. \n     MOVE is an action! value.\n\nARGUMENTS:\n     origin       [series!] \n     target       [series!] \n\nREFINEMENTS:\n     /part        => Limit the number of values inserted.\n        length       [integer!] \n\nRETURNS:\n     [series!]\n" },
  ['multiply'] = { description = "USAGE:\n     MULTIPLY value1 value2\n\nDESCRIPTION: \n     Returns the product of two values. \n     MULTIPLY is an action! value.\n\nARGUMENTS:\n     value1       [number! char! pair! tuple! vector! time!] \n     value2       [number! char! pair! tuple! vector! time!] \n\nRETURNS:\n     [number! char! pair! tuple! vector! time!]\n" },
  ['NaN?'] = { description = "USAGE:\n     NAN? value\n\nDESCRIPTION: \n     Returns TRUE if the number is Not-a-Number. \n     NAN? is a native! value.\n\nARGUMENTS:\n     value        [number!] \n\nRETURNS:\n     [logic!]\n" },
  ['native?'] = { description = "USAGE:\n     NATIVE? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     NATIVE? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['negate'] = { description = "USAGE:\n     NEGATE number\n\nDESCRIPTION: \n     Returns the opposite (additive inverse) value. \n     NEGATE is an action! value.\n\nARGUMENTS:\n     number       [number! bitset! pair! time!] \n\nRETURNS:\n     [number! bitset! pair! time!]\n" },
  ['negative?'] = { description = "USAGE:\n     NEGATIVE? number\n\nDESCRIPTION: \n     Returns TRUE if the number is negative. \n     NEGATIVE? is a native! value.\n\nARGUMENTS:\n     number       [number! time!] \n" },
  ['new-line'] = { description = "USAGE:\n     NEW-LINE position value\n\nDESCRIPTION: \n     Sets or clears the new-line marker within a block or paren. \n     NEW-LINE is a native! value.\n\nARGUMENTS:\n     position     [block! paren!] \"Position to change marker (modified)\".\n     value         \"Set TRUE for newline\".\n\nREFINEMENTS:\n     /all         => Set/clear marker to end of series.\n     /skip        => Set/clear marker periodically to the end of the series.\n        size         [integer!] \n\nRETURNS:\n     [block! paren!]\n" },
  ['new-line?'] = { description = "USAGE:\n     NEW-LINE? position\n\nDESCRIPTION: \n     Returns the state of the new-line marker within a block or paren. \n     NEW-LINE? is a native! value.\n\nARGUMENTS:\n     position     [block! paren!] \"Position to change marker\".\n\nRETURNS:\n     [block! paren!]\n" },
  ['next'] = { description = "USAGE:\n     NEXT series\n\nDESCRIPTION: \n     Returns a series at the next index. \n     NEXT is an action! value.\n\nARGUMENTS:\n     series       [series!] \n\nRETURNS:\n     [series!]\n" },
  ['none?'] = { description = "USAGE:\n     NONE? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     NONE? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['normalize-dir'] = { description = "USAGE:\n     NORMALIZE-DIR dir\n\nDESCRIPTION: \n     NORMALIZE-DIR is a function! value.\n\nARGUMENTS:\n     dir          [file! word! path!] \n" },
  ['not'] = { description = "USAGE:\n     NOT value\n\nDESCRIPTION: \n     Returns the boolean complement of a value. \n     NOT is a native! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['not-equal?'] = { description = "USAGE:\n     NOT-EQUAL? value1 value2\n\nDESCRIPTION: \n     Returns TRUE if two values are not equal. \n     NOT-EQUAL? is a native! value.\n\nARGUMENTS:\n     value1       [any-type!] \n     value2       [any-type!] \n" },
  ['now'] = { description = "USAGE:\n     NOW \n\nDESCRIPTION: \n     Returns date and time. \n     NOW is a native! value.\n\nREFINEMENTS:\n     /year        => Returns year only.\n     /month       => Returns month only.\n     /day         => Returns day of the month only.\n     /time        => Returns time only.\n     /zone        => Returns time zone offset from UCT (GMT) only.\n     /date        => Returns date only.\n     /weekday     => Returns day of the week as integer (Monday is day 1).\n     /yearday     => Returns day of the year (Julian).\n     /precise     => High precision time.\n     /utc         => Universal time (no zone).\n\nRETURNS:\n     [date! time! integer!]\n" },
  ['number?'] = { description = "USAGE:\n     NUMBER? value\n\nDESCRIPTION: \n     Returns true if the value is any type of number. \n     NUMBER? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['object'] = { description = "USAGE:\n     OBJECT spec\n\nDESCRIPTION: \n     OBJECT is a function! value.\n\nARGUMENTS:\n     spec         [block!] \n" },
  ['object?'] = { description = "USAGE:\n     OBJECT? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     OBJECT? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['odd?'] = { description = "USAGE:\n     ODD? number\n\nDESCRIPTION: \n     Returns true if the number has a remainder of 1 when divided by 2. \n     ODD? is an action! value.\n\nARGUMENTS:\n     number       [number! char! time!] \n\nRETURNS:\n     [number! char! time!]\n" },
  ['offset?'] = { description = "USAGE:\n     OFFSET? series1 series2\n\nDESCRIPTION: \n     Returns the offset between two series positions. \n     OFFSET? is a function! value.\n\nARGUMENTS:\n     series1      [series!] \n     series2      [series!] \n" },
  ['on-parse-event'] = { description = "USAGE:\n     ON-PARSE-EVENT event match? rule input stack\n\nDESCRIPTION: \n     ON-PARSE-EVENT is a function! value.\n\nARGUMENTS:\n     event        [word!] \"Trace events: push, pop, fetch, match, iterate, paren, end\".\n     match?       [logic!] \"Result of last matching operation\".\n     rule         [block!] \"Current rule at current position\".\n     input        [series!] \"Input series at next position to match\".\n     stack        [block!] \"Internal parse rules stack\".\n\nRETURNS:\n     TRUE: continue parsing, FALSE: stop and exit parsing.\n     [logic!]\n" },
  ['op?'] = { description = "USAGE:\n     OP? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     OP? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['or'] = { description = "USAGE:\n     value1 or value2\n\nDESCRIPTION: \n     Returns the first value ORed with the second. \n     OR is an op! value.\n\nARGUMENTS:\n     value1       [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n     value2       [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n\nRETURNS:\n     [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!]\n" },
  ['or~'] = { description = "USAGE:\n     OR~ value1 value2\n\nDESCRIPTION: \n     Returns the first value ORed with the second. \n     OR~ is an action! value.\n\nARGUMENTS:\n     value1       [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n     value2       [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n\nRETURNS:\n     [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!]\n" },
  ['pad'] = { description = "USAGE:\n     PAD str n\n\nDESCRIPTION: \n     Pad a FORMed value on right side with spaces. \n     PAD is a function! value.\n\nARGUMENTS:\n     str           \"Value to pad, FORM it if not a string\".\n     n            [integer!] \"Total size (in characters) of the new string\".\n\nREFINEMENTS:\n     /left        => Pad the string on left side.\n     /with        => \n        c            [char!] \"Pad with char\".\n\nRETURNS:\n     Modified input string at head.\n     [string!]\n" },
  ['pair?'] = { description = "USAGE:\n     PAIR? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     PAIR? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['paren?'] = { description = "USAGE:\n     PAREN? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     PAREN? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['parse'] = { description = "USAGE:\n     PARSE input rules\n\nDESCRIPTION: \n     PARSE is a native! value.\n\nARGUMENTS:\n     input        [binary! any-block! any-string!] \n     rules        [block!] \n\nREFINEMENTS:\n     /case        => \n     /part        => \n        length       [number! series!] \n     /trace       => \n        callback     [function! [event [word!] match? [logic!] rule [block!] input [series!] stack [block!] return: [logic!]]] \n\nRETURNS:\n     [logic! block!]\n" },
  ['parse-func-spec'] = { description = "USAGE:\n     PARSE-FUNC-SPEC spec\n\nDESCRIPTION: \n     Parses a function spec and returns an object model of it. \n     PARSE-FUNC-SPEC is a function! value.\n\nARGUMENTS:\n     spec         [block! any-function!] \n" },
  ['parse-trace'] = { description = "USAGE:\n     PARSE-TRACE input rules\n\nDESCRIPTION: \n     Wrapper for parse/trace using the default event processor. \n     PARSE-TRACE is a function! value.\n\nARGUMENTS:\n     input        [series!] \n     rules        [block!] \n\nREFINEMENTS:\n     /case        => \n     /part        => \n        limit        [integer!] \n\nRETURNS:\n     [logic! block!]\n" },
  ['path-thru'] = { description = "USAGE:\n     PATH-THRU url\n\nDESCRIPTION: \n     Returns the local disk cache path of a remote file. \n     PATH-THRU is a function! value.\n\nARGUMENTS:\n     url          [url!] \"Remote file address\".\n\nRETURNS:\n     [file!]\n" },
  ['path?'] = { description = "USAGE:\n     PATH? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     PATH? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['percent?'] = { description = "USAGE:\n     PERCENT? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     PERCENT? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['pick'] = { description = "USAGE:\n     PICK series index\n\nDESCRIPTION: \n     Returns the series value at a given index. \n     PICK is an action! value.\n\nARGUMENTS:\n     series       [series! bitset! pair! tuple! date! time!] \n     index        [scalar! any-string! any-word! block! logic! time!] \n\nRETURNS:\n     [any-type!]\n" },
  ['poke'] = { description = "USAGE:\n     POKE series index value\n\nDESCRIPTION: \n     Replaces the series value at a given index, and returns the new value. \n     POKE is an action! value.\n\nARGUMENTS:\n     series       [series! bitset!] \n     index        [scalar! any-string! any-word! block! logic!] \n     value        [any-type!] \n\nRETURNS:\n     [series! bitset!]\n" },
  ['positive?'] = { description = "USAGE:\n     POSITIVE? number\n\nDESCRIPTION: \n     Returns TRUE if the number is positive. \n     POSITIVE? is a native! value.\n\nARGUMENTS:\n     number       [number! time!] \n" },
  ['power'] = { description = "USAGE:\n     POWER number exponent\n\nDESCRIPTION: \n     Returns a number raised to a given power (exponent). \n     POWER is an action! value.\n\nARGUMENTS:\n     number       [number!] \"Base value\".\n     exponent     [integer! float!] \"The power (index) to raise the base value by\".\n\nRETURNS:\n     [number!]\n" },
  ['prin'] = { description = "USAGE:\n     PRIN value\n\nDESCRIPTION: \n     Outputs a value. \n     PRIN is a native! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['print'] = { description = "USAGE:\n     PRINT value\n\nDESCRIPTION: \n     Outputs a value followed by a newline. \n     PRINT is a native! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['probe'] = { description = "USAGE:\n     PROBE value\n\nDESCRIPTION: \n     Returns a value after printing its molded form. \n     PROBE is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['put'] = { description = "USAGE:\n     PUT series key value\n\nDESCRIPTION: \n     Replaces the value following a key, and returns the new value. \n     PUT is an action! value.\n\nARGUMENTS:\n     series       [series! map! object!] \n     key          [scalar! any-string! any-word!] \n     value        [any-type!] \n\nREFINEMENTS:\n     /case        => Perform a case-sensitive search.\n\nRETURNS:\n     [series! map! object!]\n" },
  ['pwd'] = { description = "USAGE:\n     PWD \n\nDESCRIPTION: \n     PWD is a function! value.\n" },
  ['q'] = { description = "USAGE:\n     Q \n\nDESCRIPTION: \n     Stops evaluation and exits the program. \n     Q is a function! value.\n\nREFINEMENTS:\n     /return      => \n        status       [integer!] \"Return an exit status\".\n" },
  ['quit'] = { description = "USAGE:\n     QUIT \n\nDESCRIPTION: \n     Stops evaluation and exits the program. \n     QUIT is a function! value.\n\nREFINEMENTS:\n     /return      => \n        status       [integer!] \"Return an exit status\".\n" },
  ['quit-return'] = { description = "USAGE:\n     QUIT-RETURN status\n\nDESCRIPTION: \n     Stops evaluation and exits the program with a given status. \n     QUIT-RETURN is a routine! value.\n\nARGUMENTS:\n     status       [integer!] \"Process termination value to return\".\n" },
  ['quote'] = { description = "USAGE:\n     QUOTE :value\n\nDESCRIPTION: \n     QUOTE is a function! value.\n\nARGUMENTS:\n     :value        \n" },
  ['random'] = { description = "USAGE:\n     RANDOM value\n\nDESCRIPTION: \n     Returns a random value of the same datatype; or shuffles series. \n     RANDOM is an action! value.\n\nARGUMENTS:\n     value         \"Maximum value of result (modified when series)\".\n\nREFINEMENTS:\n     /seed        => Restart or randomize.\n     /secure      => TBD: Returns a cryptographically secure random number.\n     /only        => Pick a random value from a series.\n\nRETURNS:\n     [any-type!]\n" },
  ['react'] = { description = "USAGE:\n     REACT reaction\n\nDESCRIPTION: \n     Defines a new reactive relation between two or more objects. \n     REACT is a function! value.\n\nARGUMENTS:\n     reaction     [block! function!] \"Reactive relation\".\n\nREFINEMENTS:\n     /link        => Link objects together using a reactive relation.\n        objects      [block!] \"Objects to link together\".\n     /unlink      => Removes an existing reactive relation.\n        src          [word! object! block!] \"'all word, or a reactor or a list of reactors\".\n     /later       => Run the reaction on next change instead of now.\n     /with        => Specifies an optional face object (internal use).\n        ctx          [object! set-word! none!] \"Optional context for VID faces or target set-word\".\n\nRETURNS:\n     The reactive relation or NONE if no relation was processed.\n     [block! function! none!]\n" },
  ['react?'] = { description = "USAGE:\n     REACT? reactor field\n\nDESCRIPTION: \n     Returns a reactive relation if an object's field is a reactive source. \n     REACT? is a function! value.\n\nARGUMENTS:\n     reactor      [object!] \"Object to check\".\n     field        [word!] \"Field to check\".\n\nREFINEMENTS:\n     /target      => Check if it's a target instead of a source.\n\nRETURNS:\n     Returns reaction, type or NONE.\n     [block! function! word! none!]\n" },
  ['read'] = { description = "USAGE:\n     READ source\n\nDESCRIPTION: \n     Reads from a file, URL, or other port. \n     READ is an action! value.\n\nARGUMENTS:\n     source       [file! url!] \n\nREFINEMENTS:\n     /part        => Partial read a given number of units (source relative).\n        length       [number!] \n     /seek        => Read from a specific position (source relative).\n        index        [number!] \n     /binary      => Preserves contents exactly.\n     /lines       => Convert to block of strings.\n     /info        => \n     /as          => Read with the specified encoding, default is 'UTF-8.\n        encoding     [word!] \n" },
  ['read-clipboard'] = { description = "USAGE:\n     READ-CLIPBOARD \n\nDESCRIPTION: \n     READ-CLIPBOARD is a routine! value.\n" },
  ['read-thru'] = { description = "USAGE:\n     READ-THRU url\n\nDESCRIPTION: \n     Reads a remote file through local disk cache. \n     READ-THRU is a function! value.\n\nARGUMENTS:\n     url          [url!] \"Remote file address\".\n\nREFINEMENTS:\n     /update      => Force a cache update.\n     /binary      => Use binary mode.\n" },
  ['red-complete-file'] = { description = "USAGE:\n     RED-COMPLETE-FILE str console?\n\nDESCRIPTION: \n     RED-COMPLETE-FILE is a function! value.\n\nARGUMENTS:\n     str          [string!] \n     console?     [logic!] \n" },
  ['red-complete-input'] = { description = "USAGE:\n     RED-COMPLETE-INPUT str console?\n\nDESCRIPTION: \n     RED-COMPLETE-INPUT is a function! value.\n\nARGUMENTS:\n     str          [string!] \n     console?     [logic!] \n" },
  ['red-complete-path'] = { description = "USAGE:\n     RED-COMPLETE-PATH str console?\n\nDESCRIPTION: \n     RED-COMPLETE-PATH is a function! value.\n\nARGUMENTS:\n     str          [string!] \n     console?     [logic!] \n" },
  ['reduce'] = { description = "USAGE:\n     REDUCE value\n\nDESCRIPTION: \n     Returns a copy of a block, evaluating all expressions. \n     REDUCE is a native! value.\n\nARGUMENTS:\n     value        [any-type!] \n\nREFINEMENTS:\n     /into        => Put results in out block, instead of creating a new block.\n        out          [any-block!] \"Target block for results, when /into is used\".\n" },
  ['refinement?'] = { description = "USAGE:\n     REFINEMENT? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     REFINEMENT? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['reflect'] = { description = "USAGE:\n     REFLECT value field\n\nDESCRIPTION: \n     Returns internal details about a value via reflection. \n     REFLECT is an action! value.\n\nARGUMENTS:\n     value        [any-type!] \n     field        [word!] \"spec, body, words, etc. Each datatype defines its own reflectors\".\n" },
  ['rejoin'] = { description = "USAGE:\n     REJOIN block\n\nDESCRIPTION: \n     Reduces and joins a block of values. \n     REJOIN is a function! value.\n\nARGUMENTS:\n     block        [block!] \"Values to reduce and join\".\n" },
  ['remainder'] = { description = "USAGE:\n     REMAINDER value1 value2\n\nDESCRIPTION: \n     Returns what is left over when one value is divided by another. \n     REMAINDER is an action! value.\n\nARGUMENTS:\n     value1       [number! char! pair! tuple! vector! time!] \n     value2       [number! char! pair! tuple! vector! time!] \n\nRETURNS:\n     [number! char! pair! tuple! vector! time!]\n" },
  ['remove'] = { description = "USAGE:\n     REMOVE series\n\nDESCRIPTION: \n     Returns the series at the same index after removing a value. \n     REMOVE is an action! value.\n\nARGUMENTS:\n     series       [series! bitset! none!] \n\nREFINEMENTS:\n     /part        => Removes a number of values, or values up to the given series index.\n        length       [number! char! series!] \n\nRETURNS:\n     [series! bitset! none!]\n" },
  ['remove-each'] = { description = "USAGE:\n     REMOVE-EACH 'word data body\n\nDESCRIPTION: \n     Removes values for each block that returns true. \n     REMOVE-EACH is a native! value.\n\nARGUMENTS:\n     'word        [word! block!] \"Word or block of words to set each time\".\n     data         [series!] \"The series to traverse (modified)\".\n     body         [block!] \"Block to evaluate (return TRUE to remove)\".\n" },
  ['repeat'] = { description = "USAGE:\n     REPEAT 'word value body\n\nDESCRIPTION: \n     Evaluates body a number of times, tracking iteration count. \n     REPEAT is a native! value.\n\nARGUMENTS:\n     'word        [word!] \"Iteration counter; not local to loop\".\n     value        [integer!] \"Number of times to evaluate body\".\n     body         [block!] \n" },
  ['repend'] = { description = "USAGE:\n     REPEND series value\n\nDESCRIPTION: \n     Appends a reduced value to a series and returns the series head. \n     REPEND is a function! value.\n\nARGUMENTS:\n     series       [series!] \n     value         \n\nREFINEMENTS:\n     /only        => Appends a block value as a block.\n" },
  ['replace'] = { description = "USAGE:\n     REPLACE series pattern value\n\nDESCRIPTION: \n     REPLACE is a function! value.\n\nARGUMENTS:\n     series       [series!] \n     pattern       \n     value         \n\nREFINEMENTS:\n     /all         => \n" },
  ['return'] = { description = "USAGE:\n     RETURN value\n\nDESCRIPTION: \n     Returns a value from a function. \n     RETURN is a native! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['reverse'] = { description = "USAGE:\n     REVERSE series\n\nDESCRIPTION: \n     Reverses the order of elements; returns at same position. \n     REVERSE is an action! value.\n\nARGUMENTS:\n     series       [series! pair! tuple!] \n\nREFINEMENTS:\n     /part        => Limits to a given length or position.\n        length       [number! series!] \n\nRETURNS:\n     [series! pair! tuple!]\n" },
  ['round'] = { description = "USAGE:\n     ROUND n\n\nDESCRIPTION: \n     Returns the nearest integer. Halves round up (away from zero) by default. \n     ROUND is an action! value.\n\nARGUMENTS:\n     n            [number! time! pair!] \n\nREFINEMENTS:\n     /to          => Return the nearest multiple of the scale parameter.\n        scale        [number!] \"Must be a non-zero value\".\n     /even        => Halves round toward even results.\n     /down        => Round toward zero, ignoring discarded digits. (truncate).\n     /half-down   => Halves round toward zero.\n     /floor       => Round in negative direction.\n     /ceiling     => Round in positive direction.\n     /half-ceiling => Halves round in positive direction.\n" },
  ['routine'] = { description = "USAGE:\n     ROUTINE spec body\n\nDESCRIPTION: \n     ROUTINE is a function! value.\n\nARGUMENTS:\n     spec         [block!] \n     body         [block!] \n" },
  ['routine?'] = { description = "USAGE:\n     ROUTINE? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     ROUTINE? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['same?'] = { description = "USAGE:\n     SAME? value1 value2\n\nDESCRIPTION: \n     Returns TRUE if two values have the same identity. \n     SAME? is a native! value.\n\nARGUMENTS:\n     value1       [any-type!] \n     value2       [any-type!] \n" },
  ['save'] = { description = "USAGE:\n     SAVE where value\n\nDESCRIPTION: \n     Saves a value, block, or other data to a file, URL, binary, or string. \n     SAVE is a function! value.\n\nARGUMENTS:\n     where        [file! url! string! binary! none!] \"Where to save\".\n     value         \"Value(s) to save\".\n\nREFINEMENTS:\n     /header      => Provide a Red header block (or output non-code datatypes).\n        header-data  [block! object!] \n     /all         => TBD: Save in serialized format.\n     /length      => Save the length of the script content in the header.\n     /as          => Specify the format of data; use NONE to save as plain text.\n        format       [word! none!] \"E.g. json, html, jpeg, png, redbin etc\".\n" },
  ['scalar?'] = { description = "USAGE:\n     SCALAR? value\n\nDESCRIPTION: \n     Returns true if the value is any type of scalar. \n     SCALAR? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['second'] = { description = "USAGE:\n     SECOND s\n\nDESCRIPTION: \n     Returns the second value in a series. \n     SECOND is a function! value.\n\nARGUMENTS:\n     s            [series! tuple! pair! time!] \n" },
  ['select'] = { description = "USAGE:\n     SELECT series value\n\nDESCRIPTION: \n     Find a value in a series and return the next value, or NONE. \n     SELECT is an action! value.\n\nARGUMENTS:\n     series       [series! any-object! map! none!] \n     value        [any-type!] \n\nREFINEMENTS:\n     /part        => Limit the length of the search.\n        length       [number! series!] \n     /only        => Treat a series search value as a single value.\n     /case        => Perform a case-sensitive search.\n     /same        => Use \"same?\" as comparator.\n     /any         => TBD: Use * and ? wildcards in string searches.\n     /with        => TBD: Use custom wildcards in place of * and ?.\n        wild         [string!] \n     /skip        => Treat the series as fixed size records.\n        size         [integer!] \n     /last        => Find the last occurrence of value, from the tail.\n     /reverse     => Find the last occurrence of value, from the current index.\n\nRETURNS:\n     [any-type!]\n" },
  ['series?'] = { description = "USAGE:\n     SERIES? value\n\nDESCRIPTION: \n     Returns true if the value is any type of series. \n     SERIES? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['set'] = { description = "USAGE:\n     SET word value\n\nDESCRIPTION: \n     Sets the value(s) one or more words refer to. \n     SET is a native! value.\n\nARGUMENTS:\n     word         [any-word! block! object! path!] \"Word, object, map path or block of words to set\".\n     value        [any-type!] \"Value or block of values to assign to words\".\n\nREFINEMENTS:\n     /any         => Allow UNSET as a value rather than causing an error.\n     /case        => Use case-sensitive comparison (path only).\n     /only        => Block or object value argument is set as a single value.\n     /some        => None values in a block or object value argument, are not set.\n\nRETURNS:\n     [any-type!]\n" },
  ['set-current-dir'] = { description = "USAGE:\n     SET-CURRENT-DIR path\n\nDESCRIPTION: \n     SET-CURRENT-DIR is a routine! value.\n\nARGUMENTS:\n     path         [string!] \n" },
  ['set-env'] = { description = "USAGE:\n     SET-ENV var value\n\nDESCRIPTION: \n     Sets the value of an operating system environment variable (for current process). \n     SET-ENV is a native! value.\n\nARGUMENTS:\n     var          [any-string! any-word!] \"Variable to set\".\n     value        [string! none!] \"Value to set, or NONE to unset it\".\n" },
  ['set-path?'] = { description = "USAGE:\n     SET-PATH? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     SET-PATH? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['set-quiet'] = { description = "USAGE:\n     SET-QUIET word value\n\nDESCRIPTION: \n     Set an object's field to a value without triggering object's events. \n     SET-QUIET is a routine! value.\n\nARGUMENTS:\n     word         [word!] \n     value        [any-type!] \n" },
  ['set-word?'] = { description = "USAGE:\n     SET-WORD? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     SET-WORD? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['shift'] = { description = "USAGE:\n     SHIFT data bits\n\nDESCRIPTION: \n     Perform a bit shift operation. Right shift (decreasing) by default. \n     SHIFT is a native! value.\n\nARGUMENTS:\n     data         [integer!] \n     bits         [integer!] \n\nREFINEMENTS:\n     /left        => Shift bits to the left (increasing).\n     /logical     => Use logical shift (unsigned, fill with zero).\n\nRETURNS:\n     [integer!]\n" },
  ['shift-left'] = { description = "USAGE:\n     SHIFT-LEFT data bits\n\nDESCRIPTION: \n     SHIFT-LEFT is a routine! value.\n\nARGUMENTS:\n     data         [integer!] \n     bits         [integer!] \n" },
  ['shift-logical'] = { description = "USAGE:\n     SHIFT-LOGICAL data bits\n\nDESCRIPTION: \n     SHIFT-LOGICAL is a routine! value.\n\nARGUMENTS:\n     data         [integer!] \n     bits         [integer!] \n" },
  ['shift-right'] = { description = "USAGE:\n     SHIFT-RIGHT data bits\n\nDESCRIPTION: \n     SHIFT-RIGHT is a routine! value.\n\nARGUMENTS:\n     data         [integer!] \n     bits         [integer!] \n" },
  ['sign?'] = { description = "USAGE:\n     SIGN? number\n\nDESCRIPTION: \n     Returns sign of N as 1, 0, or -1 (to use as a multiplier). \n     SIGN? is a native! value.\n\nARGUMENTS:\n     number       [number! time!] \n" },
  ['sin'] = { description = "USAGE:\n     SIN angle\n\nDESCRIPTION: \n     Returns the trigonometric sine. \n     SIN is a function! value.\n\nARGUMENTS:\n     angle        [float!] \"Angle in radians\".\n" },
  ['sine'] = { description = "USAGE:\n     SINE angle\n\nDESCRIPTION: \n     Returns the trigonometric sine. \n     SINE is a native! value.\n\nARGUMENTS:\n     angle        [number!] \n\nREFINEMENTS:\n     /radians     => Angle is specified in radians.\n\nRETURNS:\n     [float!]\n" },
  ['size?'] = { description = "USAGE:\n     SIZE? file\n\nDESCRIPTION: \n     Returns the size of a file content. \n     SIZE? is a native! value.\n\nARGUMENTS:\n     file         [file!] \n\nRETURNS:\n     [integer! none!]\n" },
  ['skip'] = { description = "USAGE:\n     SKIP series offset\n\nDESCRIPTION: \n     Returns the series relative to the current index. \n     SKIP is an action! value.\n\nARGUMENTS:\n     series       [series!] \n     offset       [integer! pair!] \n\nRETURNS:\n     [series!]\n" },
  ['sort'] = { description = "USAGE:\n     SORT series\n\nDESCRIPTION: \n     Sorts a series (modified); default sort order is ascending. \n     SORT is an action! value.\n\nARGUMENTS:\n     series       [series!] \n\nREFINEMENTS:\n     /case        => Perform a case-sensitive sort.\n     /skip        => Treat the series as fixed size records.\n        size         [integer!] \n     /compare     => Comparator offset, block or function.\n        comparator   [integer! block! any-function!] \n     /part        => Sort only part of a series.\n        length       [number! series!] \n     /all         => Compare all fields.\n     /reverse     => Reverse sort order.\n     /stable      => Stable sorting.\n\nRETURNS:\n     [series!]\n" },
  ['source'] = { description = "USAGE:\n     SOURCE 'word\n\nDESCRIPTION: \n     Print the source of a function. \n     SOURCE is a function! value.\n\nARGUMENTS:\n     'word        [any-word! any-path!] \"The name of the function\".\n" },
  ['spec-of'] = { description = "USAGE:\n     SPEC-OF value\n\nDESCRIPTION: \n     Returns the spec of a value that supports reflection. \n     SPEC-OF is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['split'] = { description = "USAGE:\n     SPLIT series dlm\n\nDESCRIPTION: \n     Break a string series into pieces using the provided delimiters. \n     SPLIT is a function! value.\n\nARGUMENTS:\n     series       [any-string!] \n     dlm          [string! char! bitset!] \n" },
  ['split-path'] = { description = "USAGE:\n     SPLIT-PATH target\n\nDESCRIPTION: \n     Splits a file or URL path. Returns a block containing path and target. \n     SPLIT-PATH is a function! value.\n\nARGUMENTS:\n     target       [file! url!] \n" },
  ['sqrt'] = { description = "USAGE:\n     SQRT number\n\nDESCRIPTION: \n     Returns the square root of a number. \n     SQRT is a function! value.\n\nARGUMENTS:\n     number       [number!] \n\nRETURNS:\n     [float!]\n" },
  ['square-root'] = { description = "USAGE:\n     SQUARE-ROOT value\n\nDESCRIPTION: \n     Returns the square root of a number. \n     SQUARE-ROOT is a native! value.\n\nARGUMENTS:\n     value        [number!] \n\nRETURNS:\n     [float!]\n" },
  ['stats'] = { description = "USAGE:\n     STATS \n\nDESCRIPTION: \n     Returns interpreter statistics. \n     STATS is a native! value.\n\nREFINEMENTS:\n     /show        => TBD:.\n     /info        => Output formatted results.\n\nRETURNS:\n     [integer! block!]\n" },
  ['strict-equal?'] = { description = "USAGE:\n     STRICT-EQUAL? value1 value2\n\nDESCRIPTION: \n     Returns TRUE if two values are equal, and also the same datatype. \n     STRICT-EQUAL? is a native! value.\n\nARGUMENTS:\n     value1       [any-type!] \n     value2       [any-type!] \n" },
  ['string?'] = { description = "USAGE:\n     STRING? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     STRING? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['subtract'] = { description = "USAGE:\n     SUBTRACT value1 value2\n\nDESCRIPTION: \n     Returns the difference between two values. \n     SUBTRACT is an action! value.\n\nARGUMENTS:\n     value1       [number! char! pair! tuple! vector! time! date!] \n     value2       [number! char! pair! tuple! vector! time! date!] \n\nRETURNS:\n     [number! char! pair! tuple! vector! time! date!]\n" },
  ['suffix?'] = { description = "USAGE:\n     SUFFIX? path\n\nDESCRIPTION: \n     Returns the suffix (extension) of a filename or url, or NONE if there is no suffix. \n     SUFFIX? is a function! value.\n\nARGUMENTS:\n     path         [file! url! string! email!] \n" },
  ['swap'] = { description = "USAGE:\n     SWAP series1 series2\n\nDESCRIPTION: \n     Swaps elements between two series or the same series. \n     SWAP is an action! value.\n\nARGUMENTS:\n     series1      [series!] \n     series2      [series!] \n\nRETURNS:\n     [series!]\n" },
  ['switch'] = { description = "USAGE:\n     SWITCH value cases\n\nDESCRIPTION: \n     Evaluates the first block following the value found in cases. \n     SWITCH is a native! value.\n\nARGUMENTS:\n     value        [any-type!] \"The value to match\".\n     cases        [block!] \n\nREFINEMENTS:\n     /default     => Specify a default block, if value is not found in cases.\n        case         [block!] \"Default block to evaluate\".\n" },
  ['tag?'] = { description = "USAGE:\n     TAG? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     TAG? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['tail'] = { description = "USAGE:\n     TAIL series\n\nDESCRIPTION: \n     Returns a series at the index after its last value. \n     TAIL is an action! value.\n\nARGUMENTS:\n     series       [series!] \n\nRETURNS:\n     [series!]\n" },
  ['tail?'] = { description = "USAGE:\n     TAIL? series\n\nDESCRIPTION: \n     Returns true if a series is past its last value. \n     TAIL? is an action! value.\n\nARGUMENTS:\n     series       [series!] \n\nRETURNS:\n     [logic!]\n" },
  ['take'] = { description = "USAGE:\n     TAKE series\n\nDESCRIPTION: \n     Removes and returns one or more elements. \n     TAKE is an action! value.\n\nARGUMENTS:\n     series       [series! none!] \n\nREFINEMENTS:\n     /part        => Specifies a length or end position.\n        length       [number! series!] \n     /deep        => Copy nested values.\n     /last        => Take it from the tail end.\n" },
  ['tan'] = { description = "USAGE:\n     TAN angle\n\nDESCRIPTION: \n     Returns the trigonometric tangent. \n     TAN is a function! value.\n\nARGUMENTS:\n     angle        [float!] \"Angle in radians\".\n" },
  ['tangent'] = { description = "USAGE:\n     TANGENT angle\n\nDESCRIPTION: \n     Returns the trigonometric tangent. \n     TANGENT is a native! value.\n\nARGUMENTS:\n     angle        [number!] \n\nREFINEMENTS:\n     /radians     => Angle is specified in radians.\n\nRETURNS:\n     [float!]\n" },
  ['third'] = { description = "USAGE:\n     THIRD s\n\nDESCRIPTION: \n     Returns the third value in a series. \n     THIRD is a function! value.\n\nARGUMENTS:\n     s            [series! tuple! time!] \n" },
  ['throw'] = { description = "USAGE:\n     THROW value\n\nDESCRIPTION: \n     Throws control back to a previous catch. \n     THROW is a native! value.\n\nARGUMENTS:\n     value        [any-type!] \"Value returned from catch\".\n\nREFINEMENTS:\n     /name        => Throws to a named catch.\n        word         [word!] \n" },
  ['time?'] = { description = "USAGE:\n     TIME? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     TIME? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['to'] = { description = "USAGE:\n     TO type spec\n\nDESCRIPTION: \n     Converts to a specified datatype. \n     TO is an action! value.\n\nARGUMENTS:\n     type         [any-type!] \"The datatype or example value\".\n     spec         [any-type!] \"The attributes of the new value\".\n" },
  ['to-binary'] = { description = "USAGE:\n     TO-BINARY value\n\nDESCRIPTION: \n     Convert to binary! value. \n     TO-BINARY is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-bitset'] = { description = "USAGE:\n     TO-BITSET value\n\nDESCRIPTION: \n     Convert to bitset! value. \n     TO-BITSET is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-block'] = { description = "USAGE:\n     TO-BLOCK value\n\nDESCRIPTION: \n     Convert to block! value. \n     TO-BLOCK is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-char'] = { description = "USAGE:\n     TO-CHAR value\n\nDESCRIPTION: \n     Convert to char! value. \n     TO-CHAR is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-date'] = { description = "USAGE:\n     TO-DATE value\n\nDESCRIPTION: \n     Convert to date! value. \n     TO-DATE is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-email'] = { description = "USAGE:\n     TO-EMAIL value\n\nDESCRIPTION: \n     Convert to email! value. \n     TO-EMAIL is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-file'] = { description = "USAGE:\n     TO-FILE value\n\nDESCRIPTION: \n     Convert to file! value. \n     TO-FILE is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-float'] = { description = "USAGE:\n     TO-FLOAT value\n\nDESCRIPTION: \n     Convert to float! value. \n     TO-FLOAT is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-get-path'] = { description = "USAGE:\n     TO-GET-PATH value\n\nDESCRIPTION: \n     Convert to get-path! value. \n     TO-GET-PATH is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-get-word'] = { description = "USAGE:\n     TO-GET-WORD value\n\nDESCRIPTION: \n     Convert to get-word! value. \n     TO-GET-WORD is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-hash'] = { description = "USAGE:\n     TO-HASH value\n\nDESCRIPTION: \n     Convert to hash! value. \n     TO-HASH is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-hex'] = { description = "USAGE:\n     TO-HEX value\n\nDESCRIPTION: \n     Converts numeric value to a hex issue! datatype (with leading # and 0's). \n     TO-HEX is a native! value.\n\nARGUMENTS:\n     value        [integer!] \n\nREFINEMENTS:\n     /size        => Specify number of hex digits in result.\n        length       [integer!] \n\nRETURNS:\n     [issue!]\n" },
  ['to-image'] = { description = "USAGE:\n     TO-IMAGE value\n\nDESCRIPTION: \n     Convert to image! value. \n     TO-IMAGE is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-integer'] = { description = "USAGE:\n     TO-INTEGER value\n\nDESCRIPTION: \n     Convert to integer! value. \n     TO-INTEGER is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-issue'] = { description = "USAGE:\n     TO-ISSUE value\n\nDESCRIPTION: \n     Convert to issue! value. \n     TO-ISSUE is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-lit-path'] = { description = "USAGE:\n     TO-LIT-PATH value\n\nDESCRIPTION: \n     Convert to lit-path! value. \n     TO-LIT-PATH is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-lit-word'] = { description = "USAGE:\n     TO-LIT-WORD value\n\nDESCRIPTION: \n     Convert to lit-word! value. \n     TO-LIT-WORD is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-local-file'] = { description = "USAGE:\n     TO-LOCAL-FILE path\n\nDESCRIPTION: \n     Converts a Red file path to the local system file path. \n     TO-LOCAL-FILE is a native! value.\n\nARGUMENTS:\n     path         [file! string!] \n\nREFINEMENTS:\n     /full        => Prepends current dir for full path (for relative paths only).\n\nRETURNS:\n     [string!]\n" },
  ['to-logic'] = { description = "USAGE:\n     TO-LOGIC value\n\nDESCRIPTION: \n     Convert to logic! value. \n     TO-LOGIC is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-map'] = { description = "USAGE:\n     TO-MAP value\n\nDESCRIPTION: \n     Convert to map! value. \n     TO-MAP is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-none'] = { description = "USAGE:\n     TO-NONE value\n\nDESCRIPTION: \n     Convert to none! value. \n     TO-NONE is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-pair'] = { description = "USAGE:\n     TO-PAIR value\n\nDESCRIPTION: \n     Convert to pair! value. \n     TO-PAIR is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-paren'] = { description = "USAGE:\n     TO-PAREN value\n\nDESCRIPTION: \n     Convert to paren! value. \n     TO-PAREN is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-path'] = { description = "USAGE:\n     TO-PATH value\n\nDESCRIPTION: \n     Convert to path! value. \n     TO-PATH is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-percent'] = { description = "USAGE:\n     TO-PERCENT value\n\nDESCRIPTION: \n     Convert to percent! value. \n     TO-PERCENT is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-red-file'] = { description = "USAGE:\n     TO-RED-FILE path\n\nDESCRIPTION: \n     TO-RED-FILE is a function! value.\n\nARGUMENTS:\n     path         [file! string!] \n\nRETURNS:\n     [file!]\n" },
  ['to-refinement'] = { description = "USAGE:\n     TO-REFINEMENT value\n\nDESCRIPTION: \n     Convert to refinement! value. \n     TO-REFINEMENT is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-set-path'] = { description = "USAGE:\n     TO-SET-PATH value\n\nDESCRIPTION: \n     Convert to set-path! value. \n     TO-SET-PATH is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-set-word'] = { description = "USAGE:\n     TO-SET-WORD value\n\nDESCRIPTION: \n     Convert to set-word! value. \n     TO-SET-WORD is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-string'] = { description = "USAGE:\n     TO-STRING value\n\nDESCRIPTION: \n     Convert to string! value. \n     TO-STRING is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-tag'] = { description = "USAGE:\n     TO-TAG value\n\nDESCRIPTION: \n     Convert to tag! value. \n     TO-TAG is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-time'] = { description = "USAGE:\n     TO-TIME value\n\nDESCRIPTION: \n     Convert to time! value. \n     TO-TIME is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-tuple'] = { description = "USAGE:\n     TO-TUPLE value\n\nDESCRIPTION: \n     Convert to tuple! value. \n     TO-TUPLE is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-typeset'] = { description = "USAGE:\n     TO-TYPESET value\n\nDESCRIPTION: \n     Convert to typeset! value. \n     TO-TYPESET is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-unset'] = { description = "USAGE:\n     TO-UNSET value\n\nDESCRIPTION: \n     Convert to unset! value. \n     TO-UNSET is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-url'] = { description = "USAGE:\n     TO-URL value\n\nDESCRIPTION: \n     Convert to url! value. \n     TO-URL is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['to-word'] = { description = "USAGE:\n     TO-WORD value\n\nDESCRIPTION: \n     Convert to word! value. \n     TO-WORD is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['trim'] = { description = "USAGE:\n     TRIM series\n\nDESCRIPTION: \n     Removes space from a string or NONE from a block. \n     TRIM is an action! value.\n\nARGUMENTS:\n     series       [string! block! hash!] \n\nREFINEMENTS:\n     /head        => Removes only from the head.\n     /tail        => Removes only from the tail.\n     /auto        => Auto indents lines relative to first line.\n     /lines       => Removes all line breaks and extra spaces.\n     /all         => Removes all whitespace.\n     /with        => Same as /all, but removes characters in 'str'.\n        str          [char! string! integer!] \n" },
  ['try'] = { description = "USAGE:\n     TRY block\n\nDESCRIPTION: \n     Tries to DO a block and returns its value or an error. \n     TRY is a native! value.\n\nARGUMENTS:\n     block        [block!] \n\nREFINEMENTS:\n     /all         => Catch also BREAK, CONTINUE, RETURN, EXIT and THROW exceptions.\n" },
  ['tuple?'] = { description = "USAGE:\n     TUPLE? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     TUPLE? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['type?'] = { description = "USAGE:\n     TYPE? value\n\nDESCRIPTION: \n     Returns the datatype of a value. \n     TYPE? is a native! value.\n\nARGUMENTS:\n     value        [any-type!] \n\nREFINEMENTS:\n     /word        => Return a word value, rather than a datatype value.\n" },
  ['typeset?'] = { description = "USAGE:\n     TYPESET? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     TYPESET? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['union'] = { description = "USAGE:\n     UNION set1 set2\n\nDESCRIPTION: \n     Returns the union of two data sets. \n     UNION is a native! value.\n\nARGUMENTS:\n     set1         [block! hash! string! bitset! typeset!] \n     set2         [block! hash! string! bitset! typeset!] \n\nREFINEMENTS:\n     /case        => Use case-sensitive comparison.\n     /skip        => Treat the series as fixed size records.\n        size         [integer!] \n\nRETURNS:\n     [block! hash! string! bitset! typeset!]\n" },
  ['unique'] = { description = "USAGE:\n     UNIQUE set\n\nDESCRIPTION: \n     Returns the data set with duplicates removed. \n     UNIQUE is a native! value.\n\nARGUMENTS:\n     set          [block! hash! string!] \n\nREFINEMENTS:\n     /case        => Use case-sensitive comparison.\n     /skip        => Treat the series as fixed size records.\n        size         [integer!] \n\nRETURNS:\n     [block! hash! string!]\n" },
  ['unless'] = { description = "USAGE:\n     UNLESS cond then-blk\n\nDESCRIPTION: \n     If conditional expression is not TRUE, evaluate block; else return NONE. \n     UNLESS is a native! value.\n\nARGUMENTS:\n     cond         [any-type!] \n     then-blk     [block!] \n" },
  ['unset'] = { description = "USAGE:\n     UNSET word\n\nDESCRIPTION: \n     Unsets the value of a word in its current context. \n     UNSET is a native! value.\n\nARGUMENTS:\n     word         [word! block!] \"Word or block of words\".\n" },
  ['unset?'] = { description = "USAGE:\n     UNSET? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     UNSET? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['until'] = { description = "USAGE:\n     UNTIL body\n\nDESCRIPTION: \n     Evaluates body until it is TRUE. \n     UNTIL is a native! value.\n\nARGUMENTS:\n     body         [block!] \n" },
  ['uppercase'] = { description = "USAGE:\n     UPPERCASE string\n\nDESCRIPTION: \n     Converts string of characters to uppercase. \n     UPPERCASE is a native! value.\n\nARGUMENTS:\n     string       [any-string! char!] \n\nREFINEMENTS:\n     /part        => Limits to a given length or position.\n        limit        [number! any-string!] \n\nRETURNS:\n     [any-string! char!]\n" },
  ['url?'] = { description = "USAGE:\n     URL? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     URL? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['value?'] = { description = "USAGE:\n     VALUE? value\n\nDESCRIPTION: \n     Returns TRUE if the word has a value. \n     VALUE? is a native! value.\n\nARGUMENTS:\n     value         \n\nRETURNS:\n     [logic!]\n" },
  ['values-of'] = { description = "USAGE:\n     VALUES-OF value\n\nDESCRIPTION: \n     Returns the list of values of a value that supports reflection. \n     VALUES-OF is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['vector?'] = { description = "USAGE:\n     VECTOR? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     VECTOR? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['wait'] = { description = "USAGE:\n     WAIT value\n\nDESCRIPTION: \n     Waits for a duration in seconds or specified time. \n     WAIT is a native! value.\n\nARGUMENTS:\n     value        [number! time! block! none!] \n\nREFINEMENTS:\n     /all         => Returns all in a block.\n" },
  ['what'] = { description = "USAGE:\n     WHAT \n\nDESCRIPTION: \n     Lists all functions, or search for values. \n     WHAT is a function! value.\n\nREFINEMENTS:\n     /with        => Search all values that contain text in their name.\n        text         [word! string!] \n     /spec        => Search for text in value specs as well.\n     /buffer      => Buffer and return output, rather than printing results.\n" },
  ['what-dir'] = { description = "USAGE:\n     WHAT-DIR \n\nDESCRIPTION: \n     WHAT-DIR is a function! value.\n" },
  ['while'] = { description = "USAGE:\n     WHILE cond body\n\nDESCRIPTION: \n     Evaluates body as long as condition block returns TRUE. \n     WHILE is a native! value.\n\nARGUMENTS:\n     cond         [block!] \"Condition block to evaluate on each iteration\".\n     body         [block!] \"Block to evaluate on each iteration\".\n" },
  ['word?'] = { description = "USAGE:\n     WORD? value\n\nDESCRIPTION: \n     Returns true if the value is this type. \n     WORD? is a function! value.\n\nARGUMENTS:\n     value        [any-type!] \n" },
  ['words-of'] = { description = "USAGE:\n     WORDS-OF value\n\nDESCRIPTION: \n     Returns the list of words of a value that supports reflection. \n     WORDS-OF is a function! value.\n\nARGUMENTS:\n     value         \n" },
  ['write'] = { description = "USAGE:\n     WRITE destination data\n\nDESCRIPTION: \n     Writes to a file, URL, or other port. \n     WRITE is an action! value.\n\nARGUMENTS:\n     destination  [file! url!] \n     data         [any-type!] \n\nREFINEMENTS:\n     /binary      => Preserves contents exactly.\n     /lines       => Write each value in a block as a separate line.\n     /info        => \n     /append      => Write data at end of file.\n     /part        => Partial write a given number of units.\n        length       [number!] \n     /seek        => Write at a specific position.\n        index        [number!] \n     /allow       => Specifies protection attributes.\n        access       [block!] \n     /as          => Write with the specified encoding, default is 'UTF-8.\n        encoding     [word!] \n" },
  ['write-clipboard'] = { description = "USAGE:\n     WRITE-CLIPBOARD data\n\nDESCRIPTION: \n     WRITE-CLIPBOARD is a routine! value.\n\nARGUMENTS:\n     data         [string!] \n" },
  ['write-stdout'] = { description = "USAGE:\n     WRITE-STDOUT str\n\nDESCRIPTION: \n     WRITE-STDOUT is a routine! value.\n\nARGUMENTS:\n     str          [string!] \n" },
  ['xor'] = { description = "USAGE:\n     value1 xor value2\n\nDESCRIPTION: \n     Returns the first value exclusive ORed with the second. \n     XOR is an op! value.\n\nARGUMENTS:\n     value1       [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n     value2       [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n\nRETURNS:\n     [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!]\n" },
  ['xor~'] = { description = "USAGE:\n     XOR~ value1 value2\n\nDESCRIPTION: \n     Returns the first value exclusive ORed with the second. \n     XOR~ is an action! value.\n\nARGUMENTS:\n     value1       [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n     value2       [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!] \n\nRETURNS:\n     [logic! integer! char! bitset! binary! typeset! pair! tuple! vector!]\n" },
  ['zero?'] = { description = "USAGE:\n     ZERO? value\n\nDESCRIPTION: \n     Returns TRUE if the value is zero. \n     ZERO? is a native! value.\n\nARGUMENTS:\n     value        [number! pair! time! char! tuple!] \n\nRETURNS:\n     [logic!]\n" },
  ['_read-input'] = { description = "USAGE:\n     _READ-INPUT prompt\n\nDESCRIPTION: \n     _READ-INPUT is a routine! value.\n\nARGUMENTS:\n     prompt       [string!] \n" },
  ['_set-buffer-history'] = { description = "USAGE:\n     _SET-BUFFER-HISTORY line hist\n\nDESCRIPTION: \n     _SET-BUFFER-HISTORY is a routine! value.\n\nARGUMENTS:\n     line         [string!] \n     hist         [block!] \n" },
}